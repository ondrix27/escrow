import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  AVAILABLE_NAMESPACES,
  ConstantsUtil,
  ContractUtil,
  NetworkUtil,
  NumberUtil,
  ParseUtil,
  SafeLocalStorage,
  SafeLocalStorageKeys,
  getSafeConnectorIdKey,
  getW3mThemeVariables
} from "./chunk-LMWIBVXG.js";
import {
  proxy,
  ref,
  snapshot,
  subscribe,
  unstable_getInternalStates
} from "./chunk-RYD2VC23.js";
import {
  erc20Abi
} from "./chunk-YXHVIMER.js";
import {
  formatUnits
} from "./chunk-HY7BOZCL.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IJ3OGCUL.js";

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var SECURE_SITE = (
  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
  (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org"
);
var ONRAMP_PROVIDERS = [
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["eip155", "solana"]
  }
];
var MELD_PUBLIC_KEY = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU";
var ConstantsUtil2 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  FIVE_SEC_MS: 5e3,
  THREE_SEC_MS: 3e3,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  SOLANA_NATIVE_TOKEN_ADDRESS: "So11111111111111111111111111111111111111111",
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  BALANCE_SUPPORTED_CHAINS: [
    ConstantsUtil.CHAIN.EVM,
    ConstantsUtil.CHAIN.SOLANA
  ],
  SEND_PARAMS_SUPPORTED_CHAINS: [ConstantsUtil.CHAIN.EVM],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NAMES_SUPPORTED_CHAIN_NAMESPACES: [ConstantsUtil.CHAIN.EVM],
  ONRAMP_SUPPORTED_CHAIN_NAMESPACES: [
    ConstantsUtil.CHAIN.EVM,
    ConstantsUtil.CHAIN.SOLANA
  ],
  PAY_WITH_EXCHANGE_SUPPORTED_CHAIN_NAMESPACES: [
    ConstantsUtil.CHAIN.EVM,
    ConstantsUtil.CHAIN.SOLANA
  ],
  ACTIVITY_ENABLED_CHAIN_NAMESPACES: [ConstantsUtil.CHAIN.EVM],
  NATIVE_TOKEN_ADDRESS: {
    eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111",
    polkadot: "0x",
    bip122: "0x",
    cosmos: "0x",
    sui: "0x",
    stacks: "0x"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  CONNECT_LABELS: {
    MOBILE: "Open and continue in the wallet app",
    WEB: "Open and continue in the wallet app"
  },
  SEND_SUPPORTED_NAMESPACES: [
    ConstantsUtil.CHAIN.EVM,
    ConstantsUtil.CHAIN.SOLANA
  ],
  DEFAULT_REMOTE_FEATURES: {
    swaps: ["1inch"],
    onramp: ["meld"],
    email: true,
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook"
    ],
    activity: true,
    reownBranding: true,
    multiWallet: false,
    emailCapture: false,
    payWithExchange: false,
    payments: false,
    reownAuthentication: false
  },
  DEFAULT_REMOTE_FEATURES_DISABLED: {
    email: false,
    socials: false,
    swaps: false,
    onramp: false,
    activity: false,
    reownBranding: false,
    emailCapture: false,
    reownAuthentication: false
  },
  DEFAULT_FEATURES: {
    receive: true,
    send: true,
    emailShowWallets: true,
    connectorTypeOrder: [
      "walletConnect",
      "recent",
      "injected",
      "featured",
      "custom",
      "external",
      "recommended"
    ],
    analytics: true,
    allWallets: true,
    legalCheckbox: false,
    smartSessions: false,
    collapseWallets: false,
    walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
    connectMethodsOrder: void 0,
    pay: false,
    reownAuthentication: false
  },
  DEFAULT_SOCIALS: [
    "google",
    "x",
    "farcaster",
    "discord",
    "apple",
    "github",
    "facebook"
  ],
  DEFAULT_ACCOUNT_TYPES: {
    bip122: "payment",
    eip155: "smartAccount",
    polkadot: "eoa",
    solana: "eoa"
  },
  ADAPTER_TYPES: {
    UNIVERSAL: "universal",
    SOLANA: "solana",
    WAGMI: "wagmi",
    ETHERS: "ethers",
    ETHERS5: "ethers5",
    BITCOIN: "bitcoin"
  },
  SIWX_DEFAULTS: {
    signOutOnDisconnect: true
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var StorageUtil = {
  // Cache expiry in milliseconds
  cacheExpiry: {
    portfolio: 3e4,
    nativeBalance: 3e4,
    ens: 3e5,
    identity: 3e5,
    transactionsHistory: 15e3,
    tokenPrice: 15e3,
    // 7 Days
    latestAppKitVersion: 6048e5
  },
  isCacheExpired(timestamp, cacheExpiry) {
    return Date.now() - timestamp > cacheExpiry;
  },
  getActiveNetworkProps() {
    const namespace = StorageUtil.getActiveNamespace();
    const caipNetworkId = StorageUtil.getActiveCaipNetworkId();
    const stringChainId = caipNetworkId ? caipNetworkId.split(":")[1] : void 0;
    const chainId = stringChainId ? isNaN(Number(stringChainId)) ? stringChainId : Number(stringChainId) : void 0;
    return {
      namespace,
      caipNetworkId,
      chainId
    };
  },
  setWalletConnectDeepLink({ name, href }) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.DEEPLINK_CHOICE, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = SafeLocalStorage.getItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setActiveNamespace(namespace) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE, namespace);
    } catch {
      console.info("Unable to set active namespace");
    }
  },
  setActiveCaipNetworkId(caipNetworkId) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID, caipNetworkId);
      StorageUtil.setActiveNamespace(caipNetworkId.split(":")[0]);
    } catch {
      console.info("Unable to set active caip network id");
    }
  },
  getActiveCaipNetworkId() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to get active caip network id");
      return void 0;
    }
  },
  deleteActiveCaipNetworkId() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to delete active caip network id");
    }
  },
  deleteConnectedConnectorId(namespace) {
    try {
      const key = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.removeItem(key);
    } catch {
      console.info("Unable to delete connected connector id");
    }
  },
  setAppKitRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists = recentWallets.find((w) => w.id === wallet.id);
      if (!exists) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        SafeLocalStorage.setItem(SafeLocalStorageKeys.RECENT_WALLETS, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set AppKit recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = SafeLocalStorage.getItem(SafeLocalStorageKeys.RECENT_WALLETS);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get AppKit recent");
    }
    return [];
  },
  setConnectedConnectorId(namespace, connectorId) {
    try {
      const key = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.setItem(key, connectorId);
    } catch {
      console.info("Unable to set Connected Connector Id");
    }
  },
  getActiveNamespace() {
    try {
      const activeNamespace = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE);
      return activeNamespace;
    } catch {
      console.info("Unable to get active namespace");
    }
    return void 0;
  },
  getConnectedConnectorId(namespace) {
    if (!namespace) {
      return void 0;
    }
    try {
      const key = getSafeConnectorIdKey(namespace);
      return SafeLocalStorage.getItem(key);
    } catch (e) {
      console.info("Unable to get connected connector id in namespace", namespace);
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set connected social provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get connected social provider");
    }
    return void 0;
  },
  deleteConnectedSocialProvider() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to delete connected social provider");
    }
  },
  getConnectedSocialUsername() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get connected social username");
    }
    return void 0;
  },
  getStoredActiveCaipNetworkId() {
    var _a;
    const storedCaipNetworkId = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    const networkId = (_a = storedCaipNetworkId == null ? void 0 : storedCaipNetworkId.split(":")) == null ? void 0 : _a[1];
    return networkId;
  },
  setConnectionStatus(status) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTION_STATUS, status);
    } catch {
      console.info("Unable to set connection status");
    }
  },
  getConnectionStatus() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTION_STATUS);
    } catch {
      return void 0;
    }
  },
  getConnectedNamespaces() {
    try {
      const namespaces = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES);
      if (!(namespaces == null ? void 0 : namespaces.length)) {
        return [];
      }
      return namespaces.split(",");
    } catch {
      return [];
    }
  },
  setConnectedNamespaces(namespaces) {
    try {
      const uniqueNamespaces = Array.from(new Set(namespaces));
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES, uniqueNamespaces.join(","));
    } catch {
      console.info("Unable to set namespaces in storage");
    }
  },
  addConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      if (!namespaces.includes(namespace)) {
        namespaces.push(namespace);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to add connected namespace");
    }
  },
  removeConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      const index = namespaces.indexOf(namespace);
      if (index > -1) {
        namespaces.splice(index, 1);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to remove connected namespace");
    }
  },
  getTelegramSocialProvider() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      console.info("Unable to get telegram social provider");
      return null;
    }
  },
  setTelegramSocialProvider(socialProvider) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER, socialProvider);
    } catch {
      console.info("Unable to set telegram social provider");
    }
  },
  removeTelegramSocialProvider() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      console.info("Unable to remove telegram social provider");
    }
  },
  getBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", caipAddress);
    }
  },
  getBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      const balanceCache = cache[caipAddress];
      if (balanceCache && !this.isCacheExpired(balanceCache.timestamp, this.cacheExpiry.portfolio)) {
        return balanceCache.balance;
      }
      StorageUtil.removeAddressFromBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateBalanceCache(params) {
    try {
      const cache = StorageUtil.getBalanceCache();
      cache[params.caipAddress] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getNativeBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromNativeBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", caipAddress);
    }
  },
  getNativeBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      const nativeBalanceCache = cache[caipAddress];
      if (nativeBalanceCache && !this.isCacheExpired(nativeBalanceCache.timestamp, this.cacheExpiry.nativeBalance)) {
        return nativeBalanceCache;
      }
      console.info("Discarding cache for address", caipAddress);
      StorageUtil.removeAddressFromBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateNativeBalanceCache(params) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      cache[params.caipAddress] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getEnsCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.ENS_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get ens name cache");
    }
    return cache;
  },
  getEnsFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      const ensCache = cache[address];
      if (ensCache && !this.isCacheExpired(ensCache.timestamp, this.cacheExpiry.ens)) {
        return ensCache.ens;
      }
      StorageUtil.removeEnsFromCache(address);
    } catch {
      console.info("Unable to get ens name from cache", address);
    }
    return void 0;
  },
  updateEnsCache(params) {
    try {
      const cache = StorageUtil.getEnsCache();
      cache[params.address] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update ens name cache", params);
    }
  },
  removeEnsFromCache(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove ens name from cache", address);
    }
  },
  getIdentityCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.IDENTITY_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get identity cache");
    }
    return cache;
  },
  getIdentityFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      const identityCache = cache[address];
      if (identityCache && !this.isCacheExpired(identityCache.timestamp, this.cacheExpiry.identity)) {
        return identityCache.identity;
      }
      StorageUtil.removeIdentityFromCache(address);
    } catch {
      console.info("Unable to get identity from cache", address);
    }
    return void 0;
  },
  updateIdentityCache(params) {
    try {
      const cache = StorageUtil.getIdentityCache();
      cache[params.address] = {
        identity: params.identity,
        timestamp: params.timestamp
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update identity cache", params);
    }
  },
  removeIdentityFromCache(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove identity from cache", address);
    }
  },
  clearAddressCache() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ENS_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.IDENTITY_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE);
    } catch {
      console.info("Unable to clear address cache");
    }
  },
  setPreferredAccountTypes(accountTypes) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PREFERRED_ACCOUNT_TYPES, JSON.stringify(accountTypes));
    } catch {
      console.info("Unable to set preferred account types", accountTypes);
    }
  },
  getPreferredAccountTypes() {
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PREFERRED_ACCOUNT_TYPES);
      if (!result) {
        return {};
      }
      return JSON.parse(result);
    } catch {
      console.info("Unable to get preferred account types");
    }
    return {};
  },
  setConnections(connections, chainNamespace) {
    try {
      const existingConnections = StorageUtil.getConnections();
      const existing = existingConnections[chainNamespace] ?? [];
      const connectorConnectionMap = /* @__PURE__ */ new Map();
      for (const conn of existing) {
        connectorConnectionMap.set(conn.connectorId, { ...conn });
      }
      for (const conn of connections) {
        const existingConn = connectorConnectionMap.get(conn.connectorId);
        const isAuth = conn.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        if (existingConn && !isAuth) {
          const existingAddrs = new Set(existingConn.accounts.map((a) => a.address.toLowerCase()));
          const newAccounts = conn.accounts.filter((a) => !existingAddrs.has(a.address.toLowerCase()));
          existingConn.accounts.push(...newAccounts);
        } else {
          connectorConnectionMap.set(conn.connectorId, { ...conn });
        }
      }
      const dedupedConnections = {
        ...existingConnections,
        [chainNamespace]: Array.from(connectorConnectionMap.values())
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTIONS, JSON.stringify(dedupedConnections));
    } catch (error) {
      console.error("Unable to sync connections to storage", error);
    }
  },
  getConnections() {
    try {
      const connectionsStorage = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTIONS);
      if (!connectionsStorage) {
        return {};
      }
      return JSON.parse(connectionsStorage);
    } catch (error) {
      console.error("Unable to get connections from storage", error);
      return {};
    }
  },
  deleteAddressFromConnection({ connectorId, address, namespace }) {
    try {
      const connections = StorageUtil.getConnections();
      const namespaceConnections = connections[namespace] ?? [];
      const connectionMap = new Map(namespaceConnections.map((conn) => [conn.connectorId, conn]));
      const connector = connectionMap.get(connectorId);
      if (connector) {
        const updatedAccounts = connector.accounts.filter((acc) => acc.address.toLowerCase() !== address.toLowerCase());
        if (updatedAccounts.length === 0) {
          connectionMap.delete(connectorId);
        } else {
          connectionMap.set(connectorId, {
            ...connector,
            accounts: connector.accounts.filter((acc) => acc.address.toLowerCase() !== address.toLowerCase())
          });
        }
      }
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTIONS, JSON.stringify({
        ...connections,
        [namespace]: Array.from(connectionMap.values())
      }));
    } catch {
      console.error(`Unable to remove address "${address}" from connector "${connectorId}" in namespace "${namespace}"`);
    }
  },
  getDisconnectedConnectorIds() {
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS);
      if (!result) {
        return {};
      }
      return JSON.parse(result);
    } catch {
      console.info("Unable to get disconnected connector ids");
    }
    return {};
  },
  addDisconnectedConnectorId(connectorId, chainNamespace) {
    try {
      const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
      const disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
      disconnectedConnectorIdsByNamespace.push(connectorId);
      SafeLocalStorage.setItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
        ...currentDisconnectedConnectorIds,
        [chainNamespace]: Array.from(new Set(disconnectedConnectorIdsByNamespace))
      }));
    } catch {
      console.error(`Unable to set disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
    }
  },
  removeDisconnectedConnectorId(connectorId, chainNamespace) {
    try {
      const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
      let disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
      disconnectedConnectorIdsByNamespace = disconnectedConnectorIdsByNamespace.filter((id) => id.toLowerCase() !== connectorId.toLowerCase());
      SafeLocalStorage.setItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
        ...currentDisconnectedConnectorIds,
        [chainNamespace]: Array.from(new Set(disconnectedConnectorIdsByNamespace))
      }));
    } catch {
      console.error(`Unable to remove disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
    }
  },
  isConnectorDisconnected(connectorId, chainNamespace) {
    try {
      const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
      const disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
      return disconnectedConnectorIdsByNamespace.some((id) => id.toLowerCase() === connectorId.toLowerCase());
    } catch {
      console.info(`Unable to get disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
    }
    return false;
  },
  getTransactionsCache() {
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE);
      return result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get transactions cache");
    }
    return {};
  },
  getTransactionsCacheForAddress({ address, chainId = "" }) {
    var _a;
    try {
      const cache = StorageUtil.getTransactionsCache();
      const transactionsCache = (_a = cache[address]) == null ? void 0 : _a[chainId];
      if (transactionsCache && !this.isCacheExpired(transactionsCache.timestamp, this.cacheExpiry.transactionsHistory)) {
        return transactionsCache.transactions;
      }
      StorageUtil.removeTransactionsCache({ address, chainId });
    } catch {
      console.info("Unable to get transactions cache");
    }
    return void 0;
  },
  updateTransactionsCache({ address, chainId = "", timestamp, transactions }) {
    try {
      const cache = StorageUtil.getTransactionsCache();
      cache[address] = {
        ...cache[address],
        [chainId]: {
          timestamp,
          transactions
        }
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update transactions cache", {
        address,
        chainId,
        timestamp,
        transactions
      });
    }
  },
  removeTransactionsCache({ address, chainId }) {
    try {
      const cache = StorageUtil.getTransactionsCache();
      const addressCache = (cache == null ? void 0 : cache[address]) || {};
      const { [chainId]: _removed, ...updatedChainData } = addressCache;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE, JSON.stringify({
        ...cache,
        [address]: updatedChainData
      }));
    } catch {
      console.info("Unable to remove transactions cache", { address, chainId });
    }
  },
  getTokenPriceCache() {
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE);
      return result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get token price cache");
    }
    return {};
  },
  getTokenPriceCacheForAddresses(addresses) {
    try {
      const cache = StorageUtil.getTokenPriceCache();
      const tokenPriceCache = cache[addresses.join(",")];
      if (tokenPriceCache && !this.isCacheExpired(tokenPriceCache.timestamp, this.cacheExpiry.tokenPrice)) {
        return tokenPriceCache.tokenPrice;
      }
      StorageUtil.removeTokenPriceCache(addresses);
    } catch {
      console.info("Unable to get token price cache for addresses", addresses);
    }
    return void 0;
  },
  updateTokenPriceCache(params) {
    try {
      const cache = StorageUtil.getTokenPriceCache();
      cache[params.addresses.join(",")] = {
        timestamp: params.timestamp,
        tokenPrice: params.tokenPrice
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update token price cache", params);
    }
  },
  removeTokenPriceCache(addresses) {
    try {
      const cache = StorageUtil.getTokenPriceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE, JSON.stringify({ ...cache, [addresses.join(",")]: void 0 }));
    } catch {
      console.info("Unable to remove token price cache", addresses);
    }
  },
  /* ----- AppKit Latest Version ------------------------- */
  getLatestAppKitVersion() {
    try {
      const result = this.getLatestAppKitVersionCache();
      const version = result == null ? void 0 : result.version;
      if (version && !this.isCacheExpired(result.timestamp, this.cacheExpiry.latestAppKitVersion)) {
        return version;
      }
      return void 0;
    } catch {
      console.info("Unable to get latest AppKit version");
    }
    return void 0;
  },
  getLatestAppKitVersionCache() {
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.LATEST_APPKIT_VERSION);
      return result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get latest AppKit version cache");
    }
    return {};
  },
  updateLatestAppKitVersion(params) {
    try {
      const cache = StorageUtil.getLatestAppKitVersionCache();
      cache.timestamp = params.timestamp;
      cache.version = params.version;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.LATEST_APPKIT_VERSION, JSON.stringify(cache));
    } catch {
      console.info("Unable to update latest AppKit version on local storage", params);
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = {
  isMobile() {
    var _a;
    if (this.isClient()) {
      return Boolean((window == null ? void 0 : window.matchMedia) && typeof window.matchMedia === "function" && ((_a = window.matchMedia("(pointer:coarse)")) == null ? void 0 : _a.matches) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network == null ? void 0 : network.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    if (!this.isMobile()) {
      return false;
    }
    const ua = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua.includes("android");
  },
  isIos() {
    if (!this.isMobile()) {
      return false;
    }
    const ua = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return ua.includes("iphone") || ua.includes("ipad");
  },
  isSafari() {
    if (!this.isClient()) {
      return false;
    }
    const ua = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return ua.includes("safari");
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil2.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry, differenceMs = ConstantsUtil2.ONE_SEC_MS) {
    return Date.now() - lastRetry >= differenceMs;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  isIframe() {
    try {
      return (window == null ? void 0 : window.self) !== (window == null ? void 0 : window.top);
    } catch (e) {
      return false;
    }
  },
  isSafeApp() {
    var _a, _b;
    if (CoreHelperUtil.isClient() && window.self !== window.top) {
      try {
        const ancestor = (_b = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a.ancestorOrigins) == null ? void 0 : _b[0];
        const safeAppUrl = "https://app.safe.global";
        if (ancestor) {
          const ancestorUrl = new URL(ancestor);
          const safeUrl = new URL(safeAppUrl);
          return ancestorUrl.hostname === safeUrl.hostname;
        }
      } catch {
        return false;
      }
    }
    return false;
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil2.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri, universalLink = null) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    let safeUniversalLink = universalLink;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    if (safeUniversalLink && !(safeUniversalLink == null ? void 0 : safeUniversalLink.endsWith("/"))) {
      safeUniversalLink = `${safeUniversalLink}/`;
    }
    if (this.isTelegram() && this.isAndroid()) {
      wcUri = encodeURIComponent(wcUri);
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      redirectUniversalLink: safeUniversalLink ? `${safeUniversalLink}wc?uri=${encodedWcUrl}` : void 0,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  getOpenTargetForPlatform(target) {
    if (target === "popupWindow") {
      return target;
    }
    if (this.isTelegram()) {
      if (StorageUtil.getTelegramSocialProvider()) {
        return "_top";
      }
      return "_blank";
    }
    return target;
  },
  openHref(href, target, features) {
    window == null ? void 0 : window.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window == null ? void 0 : window.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  isTelegram() {
    return typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Boolean(window.TelegramWebviewProxy) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.Telegram) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.TelegramWebviewProxyProto));
  },
  isPWA() {
    var _a, _b;
    if (typeof window === "undefined") {
      return false;
    }
    const isStandaloneDisplayMode = (window == null ? void 0 : window.matchMedia) && typeof window.matchMedia === "function" ? (_a = window.matchMedia("(display-mode: standalone)")) == null ? void 0 : _a.matches : false;
    const isIOSStandalone = (_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.standalone;
    return Boolean(isStandaloneDisplayMode || isIOSStandalone);
  },
  async preloadImage(src) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  parseBalance(balance, symbol) {
    let formattedBalance = "0.000";
    if (typeof balance === "string") {
      const number = Number(balance);
      if (!isNaN(number)) {
        const formattedValue = (Math.floor(number * 1e3) / 1e3).toFixed(3);
        if (formattedValue) {
          formattedBalance = formattedValue;
        }
      }
    }
    const [valueString, decimalsString] = formattedBalance.split(".");
    const value = valueString || "0";
    const decimals = decimalsString || "000";
    const formattedText = `${value}.${decimals}${symbol ? ` ${symbol}` : ""}`;
    return {
      formattedText,
      value,
      decimals,
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return ConstantsUtil.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil.PULSE_API_URL;
  },
  getUUID() {
    if (crypto == null ? void 0 : crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(error) {
    var _a, _b;
    if (typeof error === "string") {
      return error;
    } else if (typeof ((_b = (_a = error == null ? void 0 : error.issues) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id, index) => {
        approvedIndexMap[id] = index;
      });
      requestedNetworks.sort((a, b) => {
        const indexA = approvedIndexMap[a.id];
        const indexB = approvedIndexMap[b.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array) {
    let sum = 0;
    for (const item of array) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number) {
    const roundedNumber = number.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address, chain = "eip155") {
    switch (chain) {
      case "eip155":
        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
          return false;
        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
          return true;
        }
        return false;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
      default:
        return false;
    }
  },
  uniqueBy(arr, key) {
    const set = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key];
      if (set.has(keyValue)) {
        return false;
      }
      set.add(keyValue);
      return true;
    });
  },
  generateSdkVersion(adapters, platform, version) {
    const hasNoAdapters = adapters.length === 0;
    const adapterNames = hasNoAdapters ? ConstantsUtil2.ADAPTER_TYPES.UNIVERSAL : adapters.map((adapter) => adapter.adapterType).join(",");
    return `${platform}-${adapterNames}-${version}`;
  },
  // eslint-disable-next-line max-params
  createAccount(namespace, address, type, publicKey, path) {
    return {
      namespace,
      address,
      type,
      publicKey,
      path
    };
  },
  isCaipAddress(address) {
    if (typeof address !== "string") {
      return false;
    }
    const sections = address.split(":");
    const namespace = sections[0];
    return sections.filter(Boolean).length === 3 && namespace in ConstantsUtil.CHAIN_NAME_MAP;
  },
  getAccount(account) {
    if (!account) {
      return {
        address: void 0,
        chainId: void 0
      };
    }
    if (typeof account === "string") {
      return {
        address: account,
        chainId: void 0
      };
    }
    return {
      address: account.address,
      chainId: account.chainId
    };
  },
  isMac() {
    const ua = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return ua.includes("macintosh") && !ua.includes("safari");
  },
  formatTelegramSocialLoginUrl(url) {
    const valueToInject = `--${encodeURIComponent(window == null ? void 0 : window.location.href)}`;
    const paramToInject = "state=";
    const parsedUrl = new URL(url);
    if (parsedUrl.host === "auth.magic.link") {
      const providerParam = "provider_authorization_url=";
      const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);
      const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);
      return url.replace(providerUrl, encodeURIComponent(resultUrl));
    }
    return this.injectIntoUrl(url, paramToInject, valueToInject);
  },
  injectIntoUrl(url, key, appendString) {
    const keyIndex = url.indexOf(key);
    if (keyIndex === -1) {
      throw new Error(`${key} parameter not found in the URL: ${url}`);
    }
    const keyEndIndex = url.indexOf("&", keyIndex);
    const keyLength = key.length;
    const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;
    const beforeKeyValue = url.substring(0, keyIndex + keyLength);
    const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);
    const afterKeyValue = url.substring(keyEndIndex);
    const newKeyValue = currentKeyValue + appendString;
    const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;
    return newUrl;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/BalanceUtil.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/FetchUtil.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
var FetchUtil = class {
  constructor({ baseUrl: baseUrl4, clientId }) {
    this.baseUrl = baseUrl4;
    this.clientId = clientId;
  }
  async get({ headers, signal, cache, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal, cache });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) {
          url.searchParams.append(key, value);
        }
      });
    }
    if (this.clientId) {
      url.searchParams.append("clientId", this.clientId);
    }
    return url;
  }
  sendBeacon({ body, ...args }) {
    const url = this.createUrl(args);
    return navigator.sendBeacon(url.toString(), body ? JSON.stringify(body) : void 0);
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);

// node_modules/valtio/esm/vanilla/utils.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
var DEVTOOLS = Symbol();
var { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();
var isProxy$1 = (x) => proxyStateMap$1.has(x);
function proxyMap(entries2) {
  const initialData = [];
  let initialIndex = 0;
  const indexMap = /* @__PURE__ */ new Map();
  const snapMapCache = /* @__PURE__ */ new WeakMap();
  const registerSnapMap = () => {
    const cache = snapCache$1.get(vObject);
    const latestSnap = cache == null ? void 0 : cache[1];
    if (latestSnap && !snapMapCache.has(latestSnap)) {
      const clonedMap = new Map(indexMap);
      snapMapCache.set(latestSnap, clonedMap);
    }
  };
  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
  if (entries2) {
    if (typeof entries2[Symbol.iterator] !== "function") {
      throw new TypeError(
        "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
      );
    }
    for (const [key, value] of entries2) {
      indexMap.set(key, initialIndex);
      initialData[initialIndex++] = value;
    }
  }
  const vObject = {
    data: initialData,
    index: initialIndex,
    epoch: 0,
    get size() {
      if (!isProxy$1(this)) {
        registerSnapMap();
      }
      const map = getMapForThis(this);
      return map.size;
    },
    get(key) {
      const map = getMapForThis(this);
      const index = map.get(key);
      if (index === void 0) {
        this.epoch;
        return void 0;
      }
      return this.data[index];
    },
    has(key) {
      const map = getMapForThis(this);
      this.epoch;
      return map.has(key);
    },
    set(key, value) {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      const index = indexMap.get(key);
      if (index === void 0) {
        indexMap.set(key, this.index);
        this.data[this.index++] = value;
      } else {
        this.data[index] = value;
      }
      this.epoch++;
      return this;
    },
    delete(key) {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      const index = indexMap.get(key);
      if (index === void 0) {
        return false;
      }
      delete this.data[index];
      indexMap.delete(key);
      this.epoch++;
      return true;
    },
    clear() {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      this.data.length = 0;
      this.index = 0;
      this.epoch++;
      indexMap.clear();
    },
    forEach(cb) {
      this.epoch;
      const map = getMapForThis(this);
      map.forEach((index, key) => {
        cb(this.data[index], key, this);
      });
    },
    *entries() {
      this.epoch;
      const map = getMapForThis(this);
      for (const [key, index] of map) {
        yield [key, this.data[index]];
      }
    },
    *keys() {
      this.epoch;
      const map = getMapForThis(this);
      for (const key of map.keys()) {
        yield key;
      }
    },
    *values() {
      this.epoch;
      const map = getMapForThis(this);
      for (const index of map.values()) {
        yield this.data[index];
      }
    },
    [Symbol.iterator]() {
      return this.entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    toJSON() {
      return new Map(this.entries());
    }
  };
  const proxiedObject = proxy(vObject);
  Object.defineProperties(proxiedObject, {
    size: { enumerable: false },
    index: { enumerable: false },
    epoch: { enumerable: false },
    data: { enumerable: false },
    toJSON: { enumerable: false }
  });
  Object.seal(proxiedObject);
  return proxiedObject;
}
var { proxyStateMap, snapCache } = unstable_getInternalStates();

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TelemetryController.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/OptionsUtil.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var OptionsUtil = {
  getFeatureValue(key, features) {
    const optionValue = features == null ? void 0 : features[key];
    if (optionValue === void 0) {
      return ConstantsUtil2.DEFAULT_FEATURES[key];
    }
    return optionValue;
  },
  filterSocialsByPlatform(socials) {
    if (!socials || !socials.length) {
      return socials;
    }
    if (CoreHelperUtil.isTelegram()) {
      if (CoreHelperUtil.isIos()) {
        return socials.filter((s) => s !== "google");
      }
      if (CoreHelperUtil.isMac()) {
        return socials.filter((s) => s !== "x");
      }
      if (CoreHelperUtil.isAndroid()) {
        return socials.filter((s) => !["facebook", "x"].includes(s));
      }
    }
    return socials;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js
var state = proxy({
  features: ConstantsUtil2.DEFAULT_FEATURES,
  projectId: "",
  sdkType: "appkit",
  sdkVersion: "html-wagmi-undefined",
  defaultAccountTypes: ConstantsUtil2.DEFAULT_ACCOUNT_TYPES,
  enableNetworkSwitch: true,
  experimental_preferUniversalLinks: false,
  remoteFeatures: {}
});
var OptionsController = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  setOptions(options) {
    Object.assign(state, options);
  },
  setRemoteFeatures(remoteFeatures) {
    var _a, _b;
    if (!remoteFeatures) {
      return;
    }
    const newRemoteFeatures = { ...state.remoteFeatures, ...remoteFeatures };
    state.remoteFeatures = newRemoteFeatures;
    if ((_a = state.remoteFeatures) == null ? void 0 : _a.socials) {
      state.remoteFeatures.socials = OptionsUtil.filterSocialsByPlatform(state.remoteFeatures.socials);
    }
    if ((_b = state.features) == null ? void 0 : _b.pay) {
      state.remoteFeatures.email = false;
      state.remoteFeatures.socials = false;
    }
  },
  setFeatures(features) {
    var _a;
    if (!features) {
      return;
    }
    if (!state.features) {
      state.features = ConstantsUtil2.DEFAULT_FEATURES;
    }
    const newFeatures = { ...state.features, ...features };
    state.features = newFeatures;
    if (((_a = state.features) == null ? void 0 : _a.pay) && state.remoteFeatures) {
      state.remoteFeatures.email = false;
      state.remoteFeatures.socials = false;
    }
  },
  setProjectId(projectId) {
    state.projectId = projectId;
  },
  setCustomRpcUrls(customRpcUrls) {
    state.customRpcUrls = customRpcUrls;
  },
  setAllWallets(allWallets) {
    state.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state.isSiweEnabled = isSiweEnabled;
  },
  setIsUniversalProvider(isUniversalProvider) {
    state.isUniversalProvider = isUniversalProvider;
  },
  setSdkVersion(sdkVersion) {
    state.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state.metadata = metadata;
  },
  setDisableAppend(disableAppend) {
    state.disableAppend = disableAppend;
  },
  setEIP6963Enabled(enableEIP6963) {
    state.enableEIP6963 = enableEIP6963;
  },
  setDebug(debug) {
    state.debug = debug;
  },
  setEnableWalletConnect(enableWalletConnect) {
    state.enableWalletConnect = enableWalletConnect;
  },
  setEnableWalletGuide(enableWalletGuide) {
    state.enableWalletGuide = enableWalletGuide;
  },
  setEnableAuthLogger(enableAuthLogger) {
    state.enableAuthLogger = enableAuthLogger;
  },
  setEnableWallets(enableWallets) {
    state.enableWallets = enableWallets;
  },
  setPreferUniversalLinks(preferUniversalLinks) {
    state.experimental_preferUniversalLinks = preferUniversalLinks;
  },
  setSIWX(siwx) {
    if (siwx) {
      for (const [key, isVal] of Object.entries(ConstantsUtil2.SIWX_DEFAULTS)) {
        siwx[key] ?? (siwx[key] = isVal);
      }
    }
    state.siwx = siwx;
  },
  setConnectMethodsOrder(connectMethodsOrder) {
    state.features = {
      ...state.features,
      connectMethodsOrder
    };
  },
  setWalletFeaturesOrder(walletFeaturesOrder) {
    state.features = {
      ...state.features,
      walletFeaturesOrder
    };
  },
  setSocialsOrder(socialsOrder) {
    state.remoteFeatures = {
      ...state.remoteFeatures,
      socials: socialsOrder
    };
  },
  setCollapseWallets(collapseWallets) {
    state.features = {
      ...state.features,
      collapseWallets
    };
  },
  setEnableEmbedded(enableEmbedded) {
    state.enableEmbedded = enableEmbedded;
  },
  setAllowUnsupportedChain(allowUnsupportedChain) {
    state.allowUnsupportedChain = allowUnsupportedChain;
  },
  setManualWCControl(manualWCControl) {
    state.manualWCControl = manualWCControl;
  },
  setEnableNetworkSwitch(enableNetworkSwitch) {
    state.enableNetworkSwitch = enableNetworkSwitch;
  },
  setEnableReconnect(enableReconnect) {
    state.enableReconnect = enableReconnect;
  },
  setDefaultAccountTypes(defaultAccountType = {}) {
    Object.entries(defaultAccountType).forEach(([namespace, accountType]) => {
      if (accountType) {
        state.defaultAccountTypes[namespace] = accountType;
      }
    });
  },
  setUniversalProviderConfigOverride(universalProviderConfigOverride) {
    state.universalProviderConfigOverride = universalProviderConfigOverride;
  },
  getUniversalProviderConfigOverride() {
    return state.universalProviderConfigOverride;
  },
  getSnapshot() {
    return snapshot(state);
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TelemetryController.js
var DEFAULT_STATE = Object.freeze({
  enabled: true,
  events: []
});
var api = new FetchUtil({ baseUrl: CoreHelperUtil.getAnalyticsUrl(), clientId: null });
var MAX_ERRORS_PER_MINUTE = 5;
var ONE_MINUTE_MS = 60 * 1e3;
var state2 = proxy({
  ...DEFAULT_STATE
});
var TelemetryController = {
  state: state2,
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  async sendError(error, category) {
    if (!state2.enabled) {
      return;
    }
    const now = Date.now();
    const recentErrors = state2.events.filter((event) => {
      const eventTime = new Date(event.properties.timestamp || "").getTime();
      return now - eventTime < ONE_MINUTE_MS;
    });
    if (recentErrors.length >= MAX_ERRORS_PER_MINUTE) {
      return;
    }
    const errorEvent = {
      type: "error",
      event: category,
      properties: {
        errorType: error.name,
        errorMessage: error.message,
        stackTrace: error.stack,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    state2.events.push(errorEvent);
    try {
      if (typeof window === "undefined") {
        return;
      }
      const { projectId, sdkType, sdkVersion } = OptionsController.state;
      await api.post({
        path: "/e",
        params: {
          projectId,
          st: sdkType,
          sv: sdkVersion || "html-wagmi-4.2.2"
        },
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          props: {
            type: "error",
            event: category,
            errorType: error.name,
            errorMessage: error.message,
            stackTrace: error.stack
          }
        }
      });
    } catch {
    }
  },
  enable() {
    state2.enabled = true;
  },
  disable() {
    state2.enabled = false;
  },
  clearEvents() {
    state2.events = [];
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js
var AppKitError = class _AppKitError extends Error {
  constructor(message, category, originalError) {
    super(message);
    this.name = "AppKitError";
    this.category = category;
    this.originalError = originalError;
    Object.setPrototypeOf(this, _AppKitError.prototype);
    let isStackConstructedFromOriginal = false;
    if (originalError instanceof Error && typeof originalError.stack === "string" && originalError.stack) {
      const originalErrorStack = originalError.stack;
      const firstNewlineIndex = originalErrorStack.indexOf("\n");
      if (firstNewlineIndex > -1) {
        const originalFrames = originalErrorStack.substring(firstNewlineIndex + 1);
        this.stack = `${this.name}: ${this.message}
${originalFrames}`;
        isStackConstructedFromOriginal = true;
      }
    }
    if (!isStackConstructedFromOriginal) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _AppKitError);
      } else if (!this.stack) {
        this.stack = `${this.name}: ${this.message}`;
      }
    }
  }
};
function errorHandler(err, defaultCategory) {
  let errMessage = "";
  try {
    if (err instanceof Error) {
      errMessage = err.message;
    } else if (typeof err === "string") {
      errMessage = err;
    } else if (typeof err === "object" && err !== null) {
      errMessage = (err == null ? void 0 : err.message) || JSON.stringify(err);
    } else {
      errMessage = String(err);
    }
  } catch (_error) {
    errMessage = "Unknown error";
    console.error("Error parsing error message", _error);
  }
  const error = err instanceof AppKitError ? err : new AppKitError(errMessage, defaultCategory, err);
  TelemetryController.sendError(error, error.category);
  throw error;
}
function withErrorBoundary(controller12, defaultCategory = "INTERNAL_SDK_ERROR") {
  const newController = {};
  Object.keys(controller12).forEach((key) => {
    const original = controller12[key];
    if (typeof original === "function") {
      let wrapped = original;
      if (original.constructor.name === "AsyncFunction") {
        wrapped = async (...args) => {
          try {
            return await original(...args);
          } catch (err) {
            return errorHandler(err, defaultCategory);
          }
        };
      } else {
        wrapped = (...args) => {
          try {
            return original(...args);
          } catch (err) {
            return errorHandler(err, defaultCategory);
          }
        };
      }
      newController[key] = wrapped;
    } else {
      newController[key] = original;
    }
  });
  return newController;
}

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-wallet/dist/esm/exports/utils.js
var import_dist31 = __toESM(require_dist());
var import_dist32 = __toESM(require_dist2());
var import_dist33 = __toESM(require_dist3());

// node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var DEFAULT_SDK_URL = "https://secure.walletconnect.org/sdk";
var SECURE_SITE_SDK = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_URL"] : void 0) || DEFAULT_SDK_URL;
var DEFAULT_LOG_LEVEL = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_DEFAULT_LOG_LEVEL"] : void 0) || "error";
var SECURE_SITE_SDK_VERSION = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_VERSION"] : void 0) || "4";
var W3mFrameConstants = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@appkit-wallet/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
  APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
  APP_RELOAD: "@w3m-app/RELOAD",
  APP_RPC_ABORT: "@w3m-app/RPC_ABORT",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
  FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
  FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
  FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  FRAME_READY: "@w3m-frame/READY",
  FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
  FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
  FRAME_RPC_ABORT_SUCCESS: "@w3m-frame/RPC_ABORT_SUCCESS",
  FRAME_RPC_ABORT_ERROR: "@w3m-frame/RPC_ABORT_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
};
var W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints",
    "wallet_getAssets"
  ],
  NOT_SAFE_RPC_METHODS: [
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/MobileWallet.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var CUSTOM_DEEPLINK_WALLETS = {
  PHANTOM: {
    id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    url: "https://phantom.app"
  },
  SOLFLARE: {
    id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    url: "https://solflare.com"
  },
  COINBASE: {
    id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    url: "https://go.cb-w.com"
  },
  /*
   * Got details from their npm package:
   * https://www.npmjs.com/package/@binance/w3w-utils?activeTab=code
   * https://developers.binance.com/docs/binance-w3w/evm-compatible-provider#getdeeplink
   */
  BINANCE: {
    id: "2fafea35bb471d22889ccb49c08d99dd0a18a37982602c33f696a5723934ba25",
    appId: "yFK5FCqYprrXDiVFbhyRx7",
    deeplink: "bnc://app.binance.com/mp/app",
    url: "https://app.binance.com/en/download"
  }
};
var MobileWalletUtil = {
  /**
   * Handles mobile wallet redirection for wallets that have Universal Links and doesn't support WalletConnect Deep Links.
   *
   * @param {string} id - The id of the wallet.
   * @param {ChainNamespace} namespace - The namespace of the chain.
   */
  handleMobileDeeplinkRedirect(id, namespace) {
    const href = window.location.href;
    const encodedHref = encodeURIComponent(href);
    if (id === CUSTOM_DEEPLINK_WALLETS.PHANTOM.id && !("phantom" in window)) {
      const protocol = href.startsWith("https") ? "https" : "http";
      const host = href.split("/")[2];
      const encodedRef = encodeURIComponent(`${protocol}://${host}`);
      window.location.href = `${CUSTOM_DEEPLINK_WALLETS.PHANTOM.url}/ul/browse/${encodedHref}?ref=${encodedRef}`;
    }
    if (id === CUSTOM_DEEPLINK_WALLETS.SOLFLARE.id && !("solflare" in window)) {
      window.location.href = `${CUSTOM_DEEPLINK_WALLETS.SOLFLARE.url}/ul/v1/browse/${encodedHref}?ref=${encodedHref}`;
    }
    if (namespace === ConstantsUtil.CHAIN.SOLANA) {
      if (id === CUSTOM_DEEPLINK_WALLETS.COINBASE.id && !("coinbaseSolana" in window)) {
        window.location.href = `${CUSTOM_DEEPLINK_WALLETS.COINBASE.url}/dapp?cb_url=${encodedHref}`;
      }
    }
    if (namespace === ConstantsUtil.CHAIN.BITCOIN) {
      if (id === CUSTOM_DEEPLINK_WALLETS.BINANCE.id && !("binancew3w" in window)) {
        const activeCaipNetwork = ChainController.state.activeCaipNetwork;
        const startPagePath = window.btoa("/pages/browser/index");
        const startPageQuery = window.btoa(`url=${encodedHref}&defaultChainId=${(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id) ?? 1}`);
        const deeplink = new URL(CUSTOM_DEEPLINK_WALLETS.BINANCE.deeplink);
        deeplink.searchParams.set("appId", CUSTOM_DEEPLINK_WALLETS.BINANCE.appId);
        deeplink.searchParams.set("startPagePath", startPagePath);
        deeplink.searchParams.set("startPageQuery", startPageQuery);
        const universalLink = new URL(CUSTOM_DEEPLINK_WALLETS.BINANCE.url);
        universalLink.searchParams.set("_dp", window.btoa(deeplink.toString()));
        window.location.href = universalLink.toString();
      }
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AssetController.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var state3 = proxy({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
var controller = {
  state: state3,
  subscribeNetworkImages(callback) {
    return subscribe(state3.networkImages, () => callback(state3.networkImages));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state3, key, callback);
  },
  subscribe(callback) {
    return subscribe(state3, () => callback(state3));
  },
  setWalletImage(key, value) {
    state3.walletImages[key] = value;
  },
  setNetworkImage(key, value) {
    state3.networkImages[key] = value;
  },
  setChainImage(key, value) {
    state3.chainImages[key] = value;
  },
  setConnectorImage(key, value) {
    state3.connectorImages = { ...state3.connectorImages, [key]: value };
  },
  setTokenImage(key, value) {
    state3.tokenImages[key] = value;
  },
  setCurrencyImage(key, value) {
    state3.currencyImages[key] = value;
  }
};
var AssetController = withErrorBoundary(controller);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js
var namespaceImageIds = {
  // Ethereum
  eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
  // Polkadot
  polkadot: "",
  // Bitcoin
  bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
  // Cosmos
  cosmos: "",
  // Sui
  sui: "",
  // Stacks
  stacks: ""
};
var state4 = proxy({
  networkImagePromises: {}
});
var AssetUtil = {
  async fetchWalletImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    await ApiController._fetchWalletImage(imageId);
    return this.getWalletImageById(imageId);
  },
  async fetchNetworkImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    const existingImage = this.getNetworkImageById(imageId);
    if (existingImage) {
      return existingImage;
    }
    if (!state4.networkImagePromises[imageId]) {
      state4.networkImagePromises[imageId] = ApiController._fetchNetworkImage(imageId);
    }
    await state4.networkImagePromises[imageId];
    return this.getNetworkImageById(imageId);
  },
  getWalletImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.walletImages[imageId];
  },
  getWalletImage(wallet) {
    if (wallet == null ? void 0 : wallet.image_url) {
      return wallet == null ? void 0 : wallet.image_url;
    }
    if (wallet == null ? void 0 : wallet.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    var _a, _b, _c;
    if ((_a = network == null ? void 0 : network.assets) == null ? void 0 : _a.imageUrl) {
      return (_b = network == null ? void 0 : network.assets) == null ? void 0 : _b.imageUrl;
    }
    if ((_c = network == null ? void 0 : network.assets) == null ? void 0 : _c.imageId) {
      return AssetController.state.networkImages[network.assets.imageId];
    }
    return void 0;
  },
  getNetworkImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.networkImages[imageId];
  },
  getConnectorImage(connector) {
    var _a;
    if (connector == null ? void 0 : connector.imageUrl) {
      return connector.imageUrl;
    }
    if ((_a = connector == null ? void 0 : connector.info) == null ? void 0 : _a.icon) {
      return connector.info.icon;
    }
    if (connector == null ? void 0 : connector.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  },
  getChainImage(chain) {
    return AssetController.state.networkImages[namespaceImageIds[chain]];
  },
  getTokenImage(symbol) {
    if (!symbol) {
      return void 0;
    }
    return AssetController.state.tokenImages[symbol];
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var baseUrl = CoreHelperUtil.getAnalyticsUrl();
var api2 = new FetchUtil({ baseUrl, clientId: null });
var excluded = ["MODAL_CREATED"];
var MAX_PENDING_EVENTS_KB = 45;
var state5 = proxy({
  timestamp: Date.now(),
  reportedErrors: {},
  data: {
    type: "track",
    event: "MODAL_CREATED"
  },
  pendingEvents: [],
  subscribedToVisibilityChange: false
});
var EventsController = {
  state: state5,
  subscribe(callback) {
    return subscribe(state5, () => callback(state5));
  },
  getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType,
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  _setPendingEvent(payload) {
    var _a;
    try {
      let address = AccountController.state.address;
      if ("address" in payload.data && payload.data.address) {
        address = payload.data.address;
      }
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      const caipNetworkId = (_a = ChainController.getActiveCaipNetwork()) == null ? void 0 : _a.caipNetworkId;
      this.state.pendingEvents.push({
        eventId: CoreHelperUtil.getUUID(),
        url: window.location.href,
        domain: window.location.hostname,
        timestamp: payload.timestamp,
        props: {
          ...payload.data,
          address,
          properties: {
            ..."properties" in payload.data ? payload.data.properties : {},
            caipNetworkId
          }
        }
      });
      state5.reportedErrors["FORBIDDEN"] = false;
      if (JSON.stringify(state5.pendingEvents).length / 1024 > MAX_PENDING_EVENTS_KB) {
        EventsController._submitPendingEvents();
      }
    } catch (err) {
      console.warn("_setPendingEvent", err);
    }
  },
  sendEvent(data) {
    var _a;
    state5.timestamp = Date.now();
    state5.data = data;
    const MANDATORY_EVENTS = [
      "INITIALIZE",
      "CONNECT_SUCCESS",
      "SOCIAL_LOGIN_SUCCESS"
    ];
    if (((_a = OptionsController.state.features) == null ? void 0 : _a.analytics) || MANDATORY_EVENTS.includes(data.event)) {
      EventsController._setPendingEvent(state5);
    }
    this._subscribeToVisibilityChange();
  },
  _submitPendingEvents() {
    if (state5.pendingEvents.length === 0) {
      return;
    }
    try {
      api2.sendBeacon({
        path: "/batch",
        params: EventsController.getSdkProperties(),
        body: state5.pendingEvents
      });
      state5.reportedErrors["FORBIDDEN"] = false;
      state5.pendingEvents = [];
    } catch (err) {
      state5.reportedErrors["FORBIDDEN"] = true;
    }
  },
  _subscribeToVisibilityChange() {
    var _a;
    if (state5.subscribedToVisibilityChange) {
      return;
    }
    if (typeof document === "undefined") {
      return;
    }
    state5.subscribedToVisibilityChange = true;
    (_a = document == null ? void 0 : document.addEventListener) == null ? void 0 : _a.call(document, "visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        EventsController._submitPendingEvents();
      }
    });
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var baseUrl2 = CoreHelperUtil.getApiUrl();
var api3 = new FetchUtil({
  baseUrl: baseUrl2,
  clientId: null
});
var entries = 40;
var recommendedEntries = 4;
var imageCountToFetch = 20;
var state6 = proxy({
  promises: {},
  page: 1,
  count: 0,
  featured: [],
  allFeatured: [],
  recommended: [],
  allRecommended: [],
  wallets: [],
  filteredWallets: [],
  search: [],
  isAnalyticsEnabled: false,
  excludedWallets: [],
  isFetchingRecommendedWallets: false
});
var ApiController = {
  state: state6,
  subscribeKey(key, callback) {
    return subscribeKey(state6, key, callback);
  },
  _getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType || "appkit",
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  _filterOutExtensions(wallets) {
    if (OptionsController.state.isUniversalProvider) {
      return wallets.filter((w) => Boolean(w.mobile_link || w.desktop_link || w.webapp_link));
    }
    return wallets;
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api3.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api3.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api3.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api3.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api3.baseUrl}/public/getTokenImage/${symbol}`;
    const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
  },
  _filterWalletsByPlatform(wallets) {
    const walletsLength = wallets.length;
    const filteredWallets = CoreHelperUtil.isMobile() ? wallets == null ? void 0 : wallets.filter((w) => {
      if (w.mobile_link || w.webapp_link) {
        return true;
      }
      const customDeeplinkWalletIds = Object.values(CUSTOM_DEEPLINK_WALLETS).map((wallet) => wallet.id);
      return customDeeplinkWalletIds.includes(w.id);
    }) : wallets;
    const mobileFilteredOutWalletsLength = walletsLength - filteredWallets.length;
    return { filteredWallets, mobileFilteredOutWalletsLength };
  },
  async fetchProjectConfig() {
    const response = await api3.get({
      path: "/appkit/v1/config",
      params: ApiController._getSdkProperties()
    });
    return response.features;
  },
  async fetchAllowedOrigins() {
    try {
      const { allowedOrigins } = await api3.get({
        path: "/projects/v1/origins",
        params: ApiController._getSdkProperties()
      });
      return allowedOrigins;
    } catch (error) {
      if (error instanceof Error && error.cause instanceof Response) {
        const status = error.cause.status;
        if (status === ConstantsUtil.HTTP_STATUS_CODES.TOO_MANY_REQUESTS) {
          throw new Error("RATE_LIMITED", { cause: error });
        }
        if (status >= ConstantsUtil.HTTP_STATUS_CODES.SERVER_ERROR && status < 600) {
          throw new Error("SERVER_ERROR", { cause: error });
        }
        return [];
      }
      return [];
    }
  },
  async fetchNetworkImages() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const ids = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.map(({ assets }) => assets == null ? void 0 : assets.imageId).filter(Boolean).filter((imageId) => !AssetUtil.getNetworkImageById(imageId));
    if (ids) {
      await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
  },
  async fetchCurrencyImages(currencies = []) {
    await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
  },
  async fetchTokenImages(tokens = []) {
    await Promise.allSettled(tokens.map((token) => ApiController._fetchTokenImage(token)));
  },
  async fetchWallets(params) {
    var _a;
    const exclude = params.exclude ?? [];
    const sdkProperties = ApiController._getSdkProperties();
    if (sdkProperties.sv.startsWith("html-core-")) {
      exclude.push(...Object.values(CUSTOM_DEEPLINK_WALLETS).map((w) => w.id));
    }
    const wallets = await api3.get({
      path: "/getWallets",
      params: {
        ...ApiController._getSdkProperties(),
        ...params,
        page: String(params.page),
        entries: String(params.entries),
        include: (_a = params.include) == null ? void 0 : _a.join(","),
        exclude: exclude.join(",")
      }
    });
    const { filteredWallets, mobileFilteredOutWalletsLength } = ApiController._filterWalletsByPlatform(wallets == null ? void 0 : wallets.data);
    return {
      data: filteredWallets || [],
      // Keep original count for display on main page
      count: wallets == null ? void 0 : wallets.count,
      mobileFilteredOutWalletsLength
    };
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds == null ? void 0 : featuredWalletIds.length) {
      const params = {
        ...ApiController._getSdkProperties(),
        page: 1,
        entries: (featuredWalletIds == null ? void 0 : featuredWalletIds.length) ?? recommendedEntries,
        include: featuredWalletIds
      };
      const { data } = await ApiController.fetchWallets(params);
      const sortedData = [...data].sort((a, b) => featuredWalletIds.indexOf(a.id) - featuredWalletIds.indexOf(b.id));
      const images = sortedData.map((d) => d.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
      state6.featured = sortedData;
      state6.allFeatured = sortedData;
    }
  },
  async fetchRecommendedWallets() {
    try {
      state6.isFetchingRecommendedWallets = true;
      const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
      const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
      const chains = ChainController.getRequestedCaipNetworkIds().join(",");
      const params = {
        page: 1,
        entries: recommendedEntries,
        include: includeWalletIds,
        exclude,
        chains
      };
      const { data, count } = await ApiController.fetchWallets(params);
      const recent = StorageUtil.getRecentWallets();
      const recommendedImages = data.map((d) => d.image_id).filter(Boolean);
      const recentImages = recent.map((r) => r.image_id).filter(Boolean);
      await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
      state6.recommended = data;
      state6.allRecommended = data;
      state6.count = count ?? 0;
    } catch {
    } finally {
      state6.isFetchingRecommendedWallets = false;
    }
  },
  async fetchWalletsByPage({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const chains = ChainController.getRequestedCaipNetworkIds().join(",");
    const exclude = [
      ...state6.recommended.map(({ id }) => id),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const params = {
      page,
      entries,
      include: includeWalletIds,
      exclude,
      chains
    };
    const { data, count, mobileFilteredOutWalletsLength } = await ApiController.fetchWallets(params);
    state6.mobileFilteredOutWalletsLength = mobileFilteredOutWalletsLength + (state6.mobileFilteredOutWalletsLength ?? 0);
    const images = data.slice(0, imageCountToFetch).map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
    state6.wallets = CoreHelperUtil.uniqueBy([...state6.wallets, ...ApiController._filterOutExtensions(data)], "id").filter((w) => {
      var _a;
      return (_a = w.chains) == null ? void 0 : _a.some((chain) => chains.includes(chain));
    });
    state6.count = count > state6.count ? count : state6.count;
    state6.page = page;
  },
  async initializeExcludedWallets({ ids }) {
    const params = {
      page: 1,
      entries: ids.length,
      include: ids
    };
    const { data } = await ApiController.fetchWallets(params);
    if (data) {
      data.forEach((wallet) => {
        state6.excludedWallets.push({ rdns: wallet.rdns, name: wallet.name });
      });
    }
  },
  async searchWallet({ search, badge }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    const chains = ChainController.getRequestedCaipNetworkIds().join(",");
    state6.search = [];
    const params = {
      page: 1,
      entries: 100,
      search: search == null ? void 0 : search.trim(),
      badge_type: badge,
      include: includeWalletIds,
      exclude: excludeWalletIds,
      chains
    };
    const { data } = await ApiController.fetchWallets(params);
    EventsController.sendEvent({
      type: "track",
      event: "SEARCH_WALLET",
      properties: { badge: badge ?? "", search: search ?? "" }
    });
    const images = data.map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state6.search = ApiController._filterOutExtensions(data);
  },
  initPromise(key, fetchFn) {
    const existingPromise = state6.promises[key];
    if (existingPromise) {
      return existingPromise;
    }
    return state6.promises[key] = fetchFn();
  },
  prefetch({ fetchConnectorImages = true, fetchFeaturedWallets = true, fetchRecommendedWallets = true, fetchNetworkImages = true } = {}) {
    const promises = [
      fetchConnectorImages && ApiController.initPromise("connectorImages", ApiController.fetchConnectorImages),
      fetchFeaturedWallets && ApiController.initPromise("featuredWallets", ApiController.fetchFeaturedWallets),
      fetchRecommendedWallets && ApiController.initPromise("recommendedWallets", ApiController.fetchRecommendedWallets),
      fetchNetworkImages && ApiController.initPromise("networkImages", ApiController.fetchNetworkImages)
    ].filter(Boolean);
    return Promise.allSettled(promises);
  },
  prefetchAnalyticsConfig() {
    var _a;
    if ((_a = OptionsController.state.features) == null ? void 0 : _a.analytics) {
      ApiController.fetchAnalyticsConfig();
    }
  },
  async fetchAnalyticsConfig() {
    try {
      const { isAnalyticsEnabled } = await api3.get({
        path: "/getAnalyticsConfig",
        params: ApiController._getSdkProperties()
      });
      OptionsController.setFeatures({ analytics: isAnalyticsEnabled });
    } catch (error) {
      OptionsController.setFeatures({ analytics: false });
    }
  },
  filterByNamespaces(namespaces) {
    if (!(namespaces == null ? void 0 : namespaces.length)) {
      state6.featured = state6.allFeatured;
      state6.recommended = state6.allRecommended;
      return;
    }
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    state6.featured = state6.allFeatured.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
    state6.recommended = state6.allRecommended.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
    state6.filteredWallets = state6.wallets.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
  },
  clearFilterByNamespaces() {
    state6.filteredWallets = [];
  },
  setFilterByNamespace(namespace) {
    if (!namespace) {
      state6.featured = state6.allFeatured;
      state6.recommended = state6.allRecommended;
      return;
    }
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    state6.featured = state6.allFeatured.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
    state6.recommended = state6.allRecommended.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
    state6.filteredWallets = state6.wallets.filter((wallet) => {
      var _a;
      return (_a = wallet.chains) == null ? void 0 : _a.some((chain) => caipNetworkIds.includes(chain));
    });
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/NetworkUtil.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);
var NetworkUtil2 = {
  /**
   * Function to handle the network switch.
   * This function has variety of conditions to handle the network switch depending on the connectors or namespace's connection states.
   * @param args.network - The network to switch to.
   * @param args.shouldConfirmSwitch - Whether to confirm the switch. If true, the user will be asked to confirm the switch if necessary.
   * @returns void
   */
  onSwitchNetwork({ network, ignoreSwitchConfirmation = false }) {
    const currentNetwork = ChainController.state.activeCaipNetwork;
    const routerData = RouterController.state.data;
    const isSameNetwork = network.id === (currentNetwork == null ? void 0 : currentNetwork.id);
    if (isSameNetwork) {
      return;
    }
    const isCurrentNamespaceConnected = AccountController.getCaipAddress(ChainController.state.activeChain);
    const isDifferentNamespace = network.chainNamespace !== ChainController.state.activeChain;
    const isNextNamespaceConnected = AccountController.getCaipAddress(network.chainNamespace);
    const connectorId = ConnectorController.getConnectorId(ChainController.state.activeChain);
    const isConnectedWithAuth = connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
    const isSupportedForAuthConnector = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((c) => c === network.chainNamespace);
    if (ignoreSwitchConfirmation || isConnectedWithAuth && isSupportedForAuthConnector) {
      RouterController.push("SwitchNetwork", { ...routerData, network });
    } else if (
      /**
       * If user switching to a different namespace and next namespace is not connected, we need to show switch active chain view for confirmation first.
       */
      isCurrentNamespaceConnected && isDifferentNamespace && !isNextNamespaceConnected
    ) {
      RouterController.push("SwitchActiveChain", {
        switchToChain: network.chainNamespace,
        navigateTo: "Connect",
        navigateWithReplace: true,
        network
      });
    } else {
      RouterController.push("SwitchNetwork", { ...routerData, network });
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var state7 = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0,
  activeChain: void 0,
  initialized: false
});
var PublicStateController = {
  state: state7,
  subscribe(callback) {
    return subscribe(state7, () => callback(state7));
  },
  subscribeOpen(callback) {
    return subscribeKey(state7, "open", callback);
  },
  set(newState) {
    Object.assign(state7, { ...state7, ...newState });
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js
var state8 = proxy({
  loading: false,
  loadingNamespaceMap: /* @__PURE__ */ new Map(),
  open: false,
  shake: false,
  namespace: void 0
});
var controller2 = {
  state: state8,
  subscribe(callback) {
    return subscribe(state8, () => callback(state8));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state8, key, callback);
  },
  async open(options) {
    var _a, _b;
    const namespace = options == null ? void 0 : options.namespace;
    const currentNamespace = ChainController.state.activeChain;
    const isSwitchingNamespace = namespace && namespace !== currentNamespace;
    const caipAddress = (_a = ChainController.getAccountData(options == null ? void 0 : options.namespace)) == null ? void 0 : _a.caipAddress;
    const hasNoAdapters = ChainController.state.noAdapters;
    if (ConnectionController.state.wcBasic) {
      ApiController.prefetch({ fetchNetworkImages: false, fetchConnectorImages: false });
    } else {
      await ApiController.prefetch();
    }
    ConnectorController.setFilterByNamespace(options == null ? void 0 : options.namespace);
    ModalController.setLoading(true, namespace);
    if (namespace && isSwitchingNamespace) {
      const namespaceNetwork = ((_b = ChainController.getNetworkData(namespace)) == null ? void 0 : _b.caipNetwork) || ChainController.getRequestedCaipNetworks(namespace)[0];
      if (namespaceNetwork) {
        if (hasNoAdapters) {
          await ChainController.switchActiveNetwork(namespaceNetwork);
          RouterController.push("ConnectingWalletConnectBasic");
        } else {
          NetworkUtil2.onSwitchNetwork({ network: namespaceNetwork, ignoreSwitchConfirmation: true });
        }
      }
    } else if (OptionsController.state.manualWCControl || hasNoAdapters && !caipAddress) {
      if (CoreHelperUtil.isMobile()) {
        RouterController.reset("AllWallets");
      } else {
        RouterController.reset("ConnectingWalletConnectBasic");
      }
    } else if (options == null ? void 0 : options.view) {
      RouterController.reset(options.view, options.data);
    } else if (caipAddress) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state8.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected: Boolean(caipAddress) }
    });
  },
  close() {
    const isEmbeddedEnabled = OptionsController.state.enableEmbedded;
    const isConnected = Boolean(ChainController.state.activeCaipAddress);
    if (state8.open) {
      EventsController.sendEvent({
        type: "track",
        event: "MODAL_CLOSE",
        properties: { connected: isConnected }
      });
    }
    state8.open = false;
    RouterController.reset("Connect");
    ModalController.clearLoading();
    if (isEmbeddedEnabled) {
      if (isConnected) {
        RouterController.replace("Account");
      } else {
        RouterController.push("Connect");
      }
    } else {
      PublicStateController.set({ open: false });
    }
    ConnectionController.resetUri();
  },
  setLoading(loading, namespace) {
    if (namespace) {
      state8.loadingNamespaceMap.set(namespace, loading);
    }
    state8.loading = loading;
    PublicStateController.set({ loading });
  },
  clearLoading() {
    state8.loadingNamespaceMap.clear();
    state8.loading = false;
    PublicStateController.set({ loading: false });
  },
  shake() {
    if (state8.shake) {
      return;
    }
    state8.shake = true;
    setTimeout(() => {
      state8.shake = false;
    }, 500);
  }
};
var ModalController = withErrorBoundary(controller2);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var state9 = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
var controller3 = {
  state: state9,
  subscribeKey(key, callback) {
    return subscribeKey(state9, key, callback);
  },
  pushTransactionStack(action) {
    state9.transactionStack.push(action);
  },
  popTransactionStack(status) {
    const action = state9.transactionStack.pop();
    if (!action) {
      return;
    }
    const { onSuccess, onError, onCancel } = action;
    switch (status) {
      case "success":
        onSuccess == null ? void 0 : onSuccess();
        break;
      case "error":
        onError == null ? void 0 : onError();
        RouterController.goBack();
        break;
      case "cancel":
        onCancel == null ? void 0 : onCancel();
        RouterController.goBack();
        break;
      default:
    }
  },
  push(view, data) {
    if (view !== state9.view) {
      state9.view = view;
      state9.history.push(view);
      state9.data = data;
    }
  },
  reset(view, data) {
    state9.view = view;
    state9.history = [view];
    state9.data = data;
  },
  replace(view, data) {
    const lastView = state9.history.at(-1);
    const isSameView = lastView === view;
    if (!isSameView) {
      state9.view = view;
      state9.history[state9.history.length - 1] = view;
      state9.data = data;
    }
  },
  goBack() {
    var _a;
    const isConnected = ChainController.state.activeCaipAddress;
    const isFarcasterView = RouterController.state.view === "ConnectingFarcaster";
    const shouldReload = !isConnected && isFarcasterView;
    if (state9.history.length > 1) {
      state9.history.pop();
      const [last] = state9.history.slice(-1);
      if (last) {
        const isConnectView = last === "Connect";
        if (isConnected && isConnectView) {
          state9.view = "Account";
        } else {
          state9.view = last;
        }
      }
    } else {
      ModalController.close();
    }
    if ((_a = state9.data) == null ? void 0 : _a.wallet) {
      state9.data.wallet = void 0;
    }
    setTimeout(() => {
      var _a2, _b, _c;
      if (shouldReload) {
        AccountController.setFarcasterUrl(void 0, ChainController.state.activeChain);
        const authConnector = ConnectorController.getAuthConnector();
        (_a2 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a2.reload();
        const optionsState = snapshot(OptionsController.state);
        (_c = (_b = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _b.syncDappData) == null ? void 0 : _c.call(_b, {
          metadata: optionsState.metadata,
          sdkVersion: optionsState.sdkVersion,
          projectId: optionsState.projectId,
          sdkType: optionsState.sdkType
        });
      }
    }, 100);
  },
  goBackToIndex(historyIndex) {
    if (state9.history.length > 1) {
      state9.history = state9.history.slice(0, historyIndex + 1);
      const [last] = state9.history.slice(-1);
      if (last) {
        state9.view = last;
      }
    }
  },
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  }
};
var RouterController = withErrorBoundary(controller3);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ThemeController.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var state10 = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
var controller4 = {
  state: state10,
  subscribe(callback) {
    return subscribe(state10, () => callback(state10));
  },
  setThemeMode(themeMode) {
    state10.themeMode = themeMode;
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariables = controller4.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state10.themeVariables = { ...state10.themeVariables, ...themeVariables };
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariablesSnapshot = controller4.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state10.themeVariables, state10.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state10);
  }
};
var ThemeController = withErrorBoundary(controller4);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var defaultActiveConnectors = Object.fromEntries(AVAILABLE_NAMESPACES.map((namespace) => [namespace, void 0]));
var defaultFilterByNamespaceMap = Object.fromEntries(AVAILABLE_NAMESPACES.map((namespace) => [namespace, true]));
var state11 = proxy({
  allConnectors: [],
  connectors: [],
  activeConnector: void 0,
  filterByNamespace: void 0,
  activeConnectorIds: defaultActiveConnectors,
  filterByNamespaceMap: defaultFilterByNamespaceMap
});
var controller5 = {
  state: state11,
  subscribe(callback) {
    return subscribe(state11, () => {
      callback(state11);
    });
  },
  subscribeKey(key, callback) {
    return subscribeKey(state11, key, callback);
  },
  initialize(namespaces) {
    namespaces.forEach((namespace) => {
      const connectorId = StorageUtil.getConnectedConnectorId(namespace);
      if (connectorId) {
        ConnectorController.setConnectorId(connectorId, namespace);
      }
    });
  },
  setActiveConnector(connector) {
    if (connector) {
      state11.activeConnector = ref(connector);
    }
  },
  setConnectors(connectors) {
    const newConnectors = connectors.filter((newConnector) => !state11.allConnectors.some((existingConnector) => existingConnector.id === newConnector.id && ConnectorController.getConnectorName(existingConnector.name) === ConnectorController.getConnectorName(newConnector.name) && existingConnector.chain === newConnector.chain));
    newConnectors.forEach((connector) => {
      if (connector.type !== "MULTI_CHAIN") {
        state11.allConnectors.push(ref(connector));
      }
    });
    const enabledNamespaces = ConnectorController.getEnabledNamespaces();
    const connectorsFilteredByNamespaces = ConnectorController.getEnabledConnectors(enabledNamespaces);
    state11.connectors = ConnectorController.mergeMultiChainConnectors(connectorsFilteredByNamespaces);
  },
  filterByNamespaces(enabledNamespaces) {
    Object.keys(state11.filterByNamespaceMap).forEach((namespace) => {
      state11.filterByNamespaceMap[namespace] = false;
    });
    enabledNamespaces.forEach((namespace) => {
      state11.filterByNamespaceMap[namespace] = true;
    });
    ConnectorController.updateConnectorsForEnabledNamespaces();
  },
  filterByNamespace(namespace, enabled) {
    state11.filterByNamespaceMap[namespace] = enabled;
    ConnectorController.updateConnectorsForEnabledNamespaces();
  },
  updateConnectorsForEnabledNamespaces() {
    const enabledNamespaces = ConnectorController.getEnabledNamespaces();
    const enabledConnectors = ConnectorController.getEnabledConnectors(enabledNamespaces);
    const areAllNamespacesEnabled = ConnectorController.areAllNamespacesEnabled();
    state11.connectors = ConnectorController.mergeMultiChainConnectors(enabledConnectors);
    if (areAllNamespacesEnabled) {
      ApiController.clearFilterByNamespaces();
    } else {
      ApiController.filterByNamespaces(enabledNamespaces);
    }
  },
  getEnabledNamespaces() {
    return Object.entries(state11.filterByNamespaceMap).filter(([_, enabled]) => enabled).map(([namespace]) => namespace);
  },
  getEnabledConnectors(enabledNamespaces) {
    return state11.allConnectors.filter((connector) => enabledNamespaces.includes(connector.chain));
  },
  areAllNamespacesEnabled() {
    return Object.values(state11.filterByNamespaceMap).every((enabled) => enabled);
  },
  mergeMultiChainConnectors(connectors) {
    const connectorsByNameMap = ConnectorController.generateConnectorMapByName(connectors);
    const mergedConnectors = [];
    connectorsByNameMap.forEach((keyConnectors) => {
      const firstItem = keyConnectors[0];
      const isAuthConnector = (firstItem == null ? void 0 : firstItem.id) === ConstantsUtil.CONNECTOR_ID.AUTH;
      if (keyConnectors.length > 1 && firstItem) {
        mergedConnectors.push({
          name: firstItem.name,
          imageUrl: firstItem.imageUrl,
          imageId: firstItem.imageId,
          connectors: [...keyConnectors],
          type: isAuthConnector ? "AUTH" : "MULTI_CHAIN",
          // These values are just placeholders, we don't use them in multi-chain connector select screen
          chain: "eip155",
          id: (firstItem == null ? void 0 : firstItem.id) || ""
        });
      } else if (firstItem) {
        mergedConnectors.push(firstItem);
      }
    });
    return mergedConnectors;
  },
  generateConnectorMapByName(connectors) {
    const connectorsByNameMap = /* @__PURE__ */ new Map();
    connectors.forEach((connector) => {
      const { name } = connector;
      const connectorName = ConnectorController.getConnectorName(name);
      if (!connectorName) {
        return;
      }
      const connectorsByName = connectorsByNameMap.get(connectorName) || [];
      const haveSameConnector = connectorsByName.find((c) => c.chain === connector.chain);
      if (!haveSameConnector) {
        connectorsByName.push(connector);
      }
      connectorsByNameMap.set(connectorName, connectorsByName);
    });
    return connectorsByNameMap;
  },
  getConnectorName(name) {
    if (!name) {
      return name;
    }
    const nameOverrideMap = {
      "Trust Wallet": "Trust"
    };
    return nameOverrideMap[name] || name;
  },
  getUniqueConnectorsByName(connectors) {
    const uniqueConnectors = [];
    connectors.forEach((c) => {
      if (!uniqueConnectors.find((uc) => uc.chain === c.chain)) {
        uniqueConnectors.push(c);
      }
    });
    return uniqueConnectors;
  },
  addConnector(connector) {
    var _a, _b, _c;
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const authConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      (_b = (_a = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a.syncDappData) == null ? void 0 : _b.call(_a, {
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId,
        sdkType: optionsState.sdkType
      });
      (_c = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _c.syncTheme({
        themeMode,
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
      ConnectorController.setConnectors([connector]);
    } else {
      ConnectorController.setConnectors([connector]);
    }
  },
  getAuthConnector(chainNamespace) {
    var _a;
    const activeNamespace = chainNamespace || ChainController.state.activeChain;
    const authConnector = state11.connectors.find((c) => c.id === ConstantsUtil.CONNECTOR_ID.AUTH);
    if (!authConnector) {
      return void 0;
    }
    if ((_a = authConnector == null ? void 0 : authConnector.connectors) == null ? void 0 : _a.length) {
      const connector = authConnector.connectors.find((c) => c.chain === activeNamespace);
      return connector;
    }
    return authConnector;
  },
  getAnnouncedConnectorRdns() {
    return state11.connectors.filter((c) => c.type === "ANNOUNCED").map((c) => {
      var _a;
      return (_a = c.info) == null ? void 0 : _a.rdns;
    });
  },
  getConnectorById(id) {
    return state11.allConnectors.find((c) => c.id === id);
  },
  getConnector({ id, rdns, namespace }) {
    const namespaceToUse = namespace || ChainController.state.activeChain;
    const connectorsByNamespace = state11.allConnectors.filter((c) => c.chain === namespaceToUse);
    return connectorsByNamespace.find((c) => {
      var _a;
      return c.explorerId === id || ((_a = c.info) == null ? void 0 : _a.rdns) === rdns;
    });
  },
  syncIfAuthConnector(connector) {
    var _a, _b;
    if (connector.id !== "ID_AUTH") {
      return;
    }
    const authConnector = connector;
    const optionsState = snapshot(OptionsController.state);
    const themeMode = ThemeController.getSnapshot().themeMode;
    const themeVariables = ThemeController.getSnapshot().themeVariables;
    (_b = (_a = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a.syncDappData) == null ? void 0 : _b.call(_a, {
      metadata: optionsState.metadata,
      sdkVersion: optionsState.sdkVersion,
      sdkType: optionsState.sdkType,
      projectId: optionsState.projectId
    });
    authConnector.provider.syncTheme({
      themeMode,
      themeVariables,
      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
    });
  },
  /**
   * Returns the connectors filtered by namespace.
   * @param namespace - The namespace to filter the connectors by.
   * @returns ConnectorWithProviders[].
   */
  getConnectorsByNamespace(namespace) {
    const namespaceConnectors = state11.allConnectors.filter((connector) => connector.chain === namespace);
    return ConnectorController.mergeMultiChainConnectors(namespaceConnectors);
  },
  canSwitchToSmartAccount(namespace) {
    const isSmartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
    return isSmartAccountEnabled && getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA;
  },
  selectWalletConnector(wallet) {
    const connector = ConnectorController.getConnector({
      id: wallet.id,
      rdns: wallet.rdns
    });
    MobileWalletUtil.handleMobileDeeplinkRedirect((connector == null ? void 0 : connector.explorerId) || wallet.id, ChainController.state.activeChain);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector, wallet });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  },
  /**
   * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
   * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
   * @returns ConnectorWithProviders[].
   */
  getConnectors(namespace) {
    if (namespace) {
      return ConnectorController.getConnectorsByNamespace(namespace);
    }
    return ConnectorController.mergeMultiChainConnectors(state11.allConnectors);
  },
  /**
   * Sets the filter by namespace and updates the connectors.
   * @param namespace - The namespace to filter the connectors by.
   */
  setFilterByNamespace(namespace) {
    state11.filterByNamespace = namespace;
    state11.connectors = ConnectorController.getConnectors(namespace);
    ApiController.setFilterByNamespace(namespace);
  },
  setConnectorId(connectorId, namespace) {
    if (connectorId) {
      state11.activeConnectorIds = {
        ...state11.activeConnectorIds,
        [namespace]: connectorId
      };
      StorageUtil.setConnectedConnectorId(namespace, connectorId);
    }
  },
  removeConnectorId(namespace) {
    state11.activeConnectorIds = {
      ...state11.activeConnectorIds,
      [namespace]: void 0
    };
    StorageUtil.deleteConnectedConnectorId(namespace);
  },
  getConnectorId(namespace) {
    if (!namespace) {
      return void 0;
    }
    return state11.activeConnectorIds[namespace];
  },
  isConnected(namespace) {
    if (!namespace) {
      return Object.values(state11.activeConnectorIds).some((id) => Boolean(id));
    }
    return Boolean(state11.activeConnectorIds[namespace]);
  },
  resetConnectorIds() {
    state11.activeConnectorIds = { ...defaultActiveConnectors };
  }
};
var ConnectorController = withErrorBoundary(controller5);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
var UPDATE_EMAIL_INTERVAL_MS = 1e3;
var ConnectorControllerUtil = {
  checkNamespaceConnectorId(namespace, connectorId) {
    return ConnectorController.getConnectorId(namespace) === connectorId;
  },
  isSocialProvider(socialProvider) {
    return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials.includes(socialProvider);
  },
  connectWalletConnect({ walletConnect, connector, closeModalOnConnect = true, redirectViewOnModalClose = "Connect", onOpen, onConnect }) {
    return new Promise((resolve, reject) => {
      if (walletConnect) {
        ConnectorController.setActiveConnector(connector);
      }
      onOpen == null ? void 0 : onOpen(CoreHelperUtil.isMobile() && walletConnect);
      if (redirectViewOnModalClose) {
        const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
          if (!val) {
            if (RouterController.state.view !== redirectViewOnModalClose) {
              RouterController.replace(redirectViewOnModalClose);
            }
            unsubscribeModalController();
            reject(new Error("Modal closed"));
          }
        });
      }
      const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          onConnect == null ? void 0 : onConnect();
          if (closeModalOnConnect) {
            ModalController.close();
          }
          unsubscribeChainController();
          resolve(ParseUtil.parseCaipAddress(val));
        }
      });
    });
  },
  connectExternal(connector) {
    return new Promise((resolve, reject) => {
      const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          ModalController.close();
          unsubscribeChainController();
          resolve(ParseUtil.parseCaipAddress(val));
        }
      });
      ConnectionController.connectExternal(connector, connector.chain).catch(() => {
        unsubscribeChainController();
        reject(new Error("Connection rejected"));
      });
    });
  },
  connectSocial({ social, namespace, closeModalOnConnect = true, onOpenFarcaster, onConnect }) {
    let socialWindow = AccountController.state.socialWindow;
    let socialProvider = AccountController.state.socialProvider;
    let connectingSocial = false;
    let popupWindow = null;
    const namespaceToUse = namespace || ChainController.state.activeChain;
    const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
      if (val) {
        if (closeModalOnConnect) {
          ModalController.close();
        }
        unsubscribeChainController();
      }
    });
    return new Promise((resolve, reject) => {
      async function handleSocialConnection(event) {
        var _a;
        if ((_a = event.data) == null ? void 0 : _a.resultUri) {
          if (event.origin === ConstantsUtil.SECURE_SITE_SDK_ORIGIN) {
            window.removeEventListener("message", handleSocialConnection, false);
            try {
              const authConnector = ConnectorController.getAuthConnector(namespaceToUse);
              if (authConnector && !connectingSocial) {
                if (socialWindow) {
                  socialWindow.close();
                  AccountController.setSocialWindow(void 0, namespaceToUse);
                  socialWindow = AccountController.state.socialWindow;
                }
                connectingSocial = true;
                const uri = event.data.resultUri;
                if (socialProvider) {
                  EventsController.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                    properties: { provider: socialProvider }
                  });
                }
                if (socialProvider) {
                  StorageUtil.setConnectedSocialProvider(socialProvider);
                  await ConnectionController.connectExternal({
                    id: authConnector.id,
                    type: authConnector.type,
                    socialUri: uri
                  }, authConnector.chain);
                  const caipAddress = ChainController.state.activeCaipAddress;
                  if (!caipAddress) {
                    reject(new Error("Failed to connect"));
                    return;
                  }
                  resolve(ParseUtil.parseCaipAddress(caipAddress));
                  EventsController.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_SUCCESS",
                    properties: {
                      provider: socialProvider
                    }
                  });
                }
              }
            } catch (err) {
              if (socialProvider) {
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_ERROR",
                  properties: { provider: socialProvider }
                });
              }
              reject(new Error("Failed to connect"));
            }
          } else if (socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: socialProvider }
            });
          }
        }
      }
      async function connectSocial() {
        if (social) {
          AccountController.setSocialProvider(social, namespaceToUse);
          socialProvider = AccountController.state.socialProvider;
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_STARTED",
            properties: { provider: socialProvider }
          });
        }
        if (socialProvider === "farcaster") {
          onOpenFarcaster == null ? void 0 : onOpenFarcaster();
          const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
            if (!val && social === "farcaster") {
              reject(new Error("Popup closed"));
              onConnect == null ? void 0 : onConnect();
              unsubscribeModalController();
            }
          });
          const authConnector = ConnectorController.getAuthConnector();
          if (authConnector) {
            if (!AccountController.state.farcasterUrl) {
              try {
                const { url } = await authConnector.provider.getFarcasterUri();
                AccountController.setFarcasterUrl(url, namespaceToUse);
              } catch {
                reject(new Error("Failed to connect to farcaster"));
              }
            }
          }
        } else {
          const authConnector = ConnectorController.getAuthConnector();
          popupWindow = CoreHelperUtil.returnOpenHref(`${ConstantsUtil.SECURE_SITE_SDK_ORIGIN}/loading`, "popupWindow", "width=600,height=800,scrollbars=yes");
          try {
            if (authConnector && socialProvider) {
              const { uri } = await authConnector.provider.getSocialRedirectUri({
                provider: socialProvider
              });
              if (popupWindow && uri) {
                AccountController.setSocialWindow(popupWindow, namespaceToUse);
                socialWindow = AccountController.state.socialWindow;
                popupWindow.location.href = uri;
                const interval = setInterval(() => {
                  if ((socialWindow == null ? void 0 : socialWindow.closed) && !connectingSocial) {
                    reject(new Error("Popup closed"));
                    clearInterval(interval);
                  }
                }, 1e3);
                window.addEventListener("message", handleSocialConnection, false);
              } else {
                popupWindow == null ? void 0 : popupWindow.close();
                reject(new Error("Failed to initiate social connection"));
              }
            }
          } catch {
            reject(new Error("Failed to initiate social connection"));
            popupWindow == null ? void 0 : popupWindow.close();
          }
        }
      }
      connectSocial();
    });
  },
  connectEmail({ closeModalOnConnect = true, redirectViewOnModalClose = "Connect", onOpen, onConnect }) {
    return new Promise((resolve, reject) => {
      onOpen == null ? void 0 : onOpen();
      if (redirectViewOnModalClose) {
        const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
          if (!val) {
            if (RouterController.state.view !== redirectViewOnModalClose) {
              RouterController.replace(redirectViewOnModalClose);
            }
            unsubscribeModalController();
            reject(new Error("Modal closed"));
          }
        });
      }
      const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          onConnect == null ? void 0 : onConnect();
          if (closeModalOnConnect) {
            ModalController.close();
          }
          unsubscribeChainController();
          resolve(ParseUtil.parseCaipAddress(val));
        }
      });
    });
  },
  async updateEmail() {
    const connectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      throw new Error("No auth connector found");
    }
    if (connectorId !== ConstantsUtil.CONNECTOR_ID.AUTH) {
      throw new Error("Not connected to email or social");
    }
    const initialEmail = authConnector.provider.getEmail() ?? "";
    await ModalController.open({
      view: "UpdateEmailWallet",
      data: {
        email: initialEmail,
        redirectView: void 0
      }
    });
    return new Promise((resolve, reject) => {
      const interval = setInterval(() => {
        const newEmail = authConnector.provider.getEmail() ?? "";
        if (newEmail !== initialEmail) {
          ModalController.close();
          clearInterval(interval);
          unsubscribeModalController();
          resolve({ email: newEmail });
        }
      }, UPDATE_EMAIL_INTERVAL_MS);
      const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
        if (!val) {
          if (RouterController.state.view !== "Connect") {
            RouterController.push("Connect");
          }
          clearInterval(interval);
          unsubscribeModalController();
          reject(new Error("Modal closed"));
        }
      });
    });
  },
  canSwitchToSmartAccount(namespace) {
    const isSmartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
    return isSmartAccountEnabled && getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
function getActiveNetworkTokenAddress() {
  var _a, _b;
  const namespace = ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.chainNamespace) || "eip155";
  const chainId = ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.id) || 1;
  const address = ConstantsUtil2.NATIVE_TOKEN_ADDRESS[namespace];
  return `${namespace}:${chainId}:${address}`;
}
function getPreferredAccountType(namespace) {
  var _a;
  const preferredAccountType = (_a = ChainController.getAccountData(namespace)) == null ? void 0 : _a.preferredAccountType;
  return preferredAccountType;
}
function getActiveCaipNetwork(chainNamespace) {
  var _a, _b;
  if (chainNamespace) {
    return (_b = (_a = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a.networkState) == null ? void 0 : _b.caipNetwork;
  }
  return ChainController.state.activeCaipNetwork;
}

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectionControllerUtil.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
var ConnectionControllerUtil = {
  getConnectionStatus(connection, namespace) {
    const connectedConnectorId = ConnectorController.state.activeConnectorIds[namespace];
    const connections = ConnectionController.getConnections(namespace);
    const isConnectorConnected = Boolean(connectedConnectorId) && connection.connectorId === connectedConnectorId;
    if (isConnectorConnected) {
      return "connected";
    }
    const isConnectionConnected = connections.some((c) => c.connectorId.toLowerCase() === connection.connectorId.toLowerCase());
    if (isConnectionConnected) {
      return "active";
    }
    return "disconnected";
  },
  excludeConnectorAddressFromConnections({ connections, connectorId, addresses }) {
    return connections.map((connection) => {
      const isConnectorMatch = connectorId ? connection.connectorId.toLowerCase() === connectorId.toLowerCase() : false;
      if (isConnectorMatch && addresses) {
        const filteredAccounts = connection.accounts.filter((account) => {
          const isAddressIncluded = addresses.some((address) => address.toLowerCase() === account.address.toLowerCase());
          return !isAddressIncluded;
        });
        return { ...connection, accounts: filteredAccounts };
      }
      return connection;
    });
  },
  excludeExistingConnections(connectorIds, newConnections) {
    const existingConnectorIds = new Set(connectorIds);
    return newConnections.filter((c) => !existingConnectorIds.has(c.connectorId));
  },
  getConnectionsByConnectorId(connections, connectorId) {
    return connections.filter((c) => c.connectorId.toLowerCase() === connectorId.toLowerCase());
  },
  getConnectionsData(namespace) {
    var _a;
    const isMultiWalletEnabled = Boolean((_a = OptionsController.state.remoteFeatures) == null ? void 0 : _a.multiWallet);
    const activeConnectorId = ConnectorController.state.activeConnectorIds[namespace];
    const connections = ConnectionController.getConnections(namespace);
    const recentConnections = ConnectionController.state.recentConnections.get(namespace) ?? [];
    const recentConnectionsWithCurrentActiveConnectors = recentConnections.filter((connection) => ConnectorController.getConnectorById(connection.connectorId));
    const dedupedRecentConnections = ConnectionControllerUtil.excludeExistingConnections([...connections.map((c) => c.connectorId), ...activeConnectorId ? [activeConnectorId] : []], recentConnectionsWithCurrentActiveConnectors);
    if (!isMultiWalletEnabled) {
      return {
        connections: connections.filter((c) => c.connectorId.toLowerCase() === (activeConnectorId == null ? void 0 : activeConnectorId.toLowerCase())),
        recentConnections: []
      };
    }
    return {
      connections,
      recentConnections: dedupedRecentConnections
    };
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var DEFAULT_STATE2 = Object.freeze({
  message: "",
  variant: "success",
  svg: void 0,
  open: false,
  autoClose: true
});
var state12 = proxy({
  ...DEFAULT_STATE2
});
var controller6 = {
  state: state12,
  subscribeKey(key, callback) {
    return subscribeKey(state12, key, callback);
  },
  showLoading(message, options = {}) {
    this._showMessage({ message, variant: "loading", ...options });
  },
  showSuccess(message) {
    this._showMessage({ message, variant: "success" });
  },
  showSvg(message, svg) {
    this._showMessage({ message, svg });
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    this._showMessage({ message: errorMessage, variant: "error" });
  },
  hide() {
    state12.message = DEFAULT_STATE2.message;
    state12.variant = DEFAULT_STATE2.variant;
    state12.svg = DEFAULT_STATE2.svg;
    state12.open = DEFAULT_STATE2.open;
    state12.autoClose = DEFAULT_STATE2.autoClose;
  },
  _showMessage({ message, svg, variant = "success", autoClose = DEFAULT_STATE2.autoClose }) {
    if (state12.open) {
      state12.open = false;
      setTimeout(() => {
        state12.message = message;
        state12.variant = variant;
        state12.svg = svg;
        state12.open = true;
        state12.autoClose = autoClose;
      }, 150);
    } else {
      state12.message = message;
      state12.variant = variant;
      state12.svg = svg;
      state12.open = true;
      state12.autoClose = autoClose;
    }
  }
};
var SnackController = controller6;

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js
var state13 = proxy({
  transactions: [],
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: false,
  empty: false,
  next: void 0
});
var controller7 = {
  state: state13,
  subscribe(callback) {
    return subscribe(state13, () => callback(state13));
  },
  setLastNetworkInView(lastNetworkInView) {
    state13.lastNetworkInView = lastNetworkInView;
  },
  async fetchTransactions(accountAddress) {
    var _a;
    if (!accountAddress) {
      throw new Error("Transactions can't be fetched without an accountAddress");
    }
    state13.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        cursor: state13.next,
        chainId: (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId
      });
      const nonSpamTransactions = TransactionsController.filterSpamTransactions(response.data);
      const sameChainTransactions = TransactionsController.filterByConnectedChain(nonSpamTransactions);
      const filteredTransactions = [...state13.transactions, ...sameChainTransactions];
      state13.loading = false;
      state13.transactions = filteredTransactions;
      state13.transactionsByYear = TransactionsController.groupTransactionsByYearAndMonth(state13.transactionsByYear, sameChainTransactions);
      state13.empty = filteredTransactions.length === 0;
      state13.next = response.next ? response.next : void 0;
    } catch (error) {
      const activeChainNamespace = ChainController.state.activeChain;
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId: OptionsController.state.projectId,
          cursor: state13.next,
          isSmartAccount: getPreferredAccountType(activeChainNamespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state13.loading = false;
      state13.empty = true;
      state13.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a, b) => new Date(b.metadata.minedAt).getTime() - new Date(a.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => {
        var _a;
        return ((_a = transfer.nft_info) == null ? void 0 : _a.flags.is_spam) === true;
      });
      return !isAllSpam;
    });
  },
  filterByConnectedChain(transactions) {
    var _a;
    const chainId = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId;
    const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
    return filteredTransactions;
  },
  clearCursor() {
    state13.next = void 0;
  },
  resetTransactions() {
    state13.transactions = [];
    state13.transactionsByYear = {};
    state13.lastNetworkInView = void 0;
    state13.loading = false;
    state13.empty = false;
    state13.next = void 0;
  }
};
var TransactionsController = withErrorBoundary(controller7, "API_ERROR");

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js
var state14 = proxy({
  connections: /* @__PURE__ */ new Map(),
  recentConnections: /* @__PURE__ */ new Map(),
  isSwitchingConnection: false,
  wcError: false,
  buffering: false,
  status: "disconnected"
});
var wcConnectionPromise;
var controller8 = {
  state: state14,
  subscribe(callback) {
    return subscribe(state14, () => callback(state14));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state14, key, callback);
  },
  _getClient() {
    return state14._client;
  },
  setClient(client) {
    state14._client = ref(client);
  },
  initialize(adapters) {
    const namespaces = adapters.filter((a) => Boolean(a.namespace)).map((a) => a.namespace);
    ConnectionController.syncStorageConnections(namespaces);
  },
  syncStorageConnections(namespaces) {
    const storageConnections = StorageUtil.getConnections();
    const namespacesToSync = namespaces ?? Array.from(ChainController.state.chains.keys());
    for (const namespace of namespacesToSync) {
      const storageConnectionsByNamespace = storageConnections[namespace] ?? [];
      const recentConnectionsMap = new Map(state14.recentConnections);
      recentConnectionsMap.set(namespace, storageConnectionsByNamespace);
      state14.recentConnections = recentConnectionsMap;
    }
  },
  getConnections(namespace) {
    return namespace ? state14.connections.get(namespace) ?? [] : [];
  },
  hasAnyConnection(connectorId) {
    const connections = ConnectionController.state.connections;
    return Array.from(connections.values()).flatMap((_connections) => _connections).some(({ connectorId: _connectorId }) => _connectorId === connectorId);
  },
  async connectWalletConnect({ cache = "auto" } = {}) {
    var _a, _b, _c, _d;
    const isInTelegramOrSafariIos = CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari() && CoreHelperUtil.isIos();
    if (cache === "always" || cache === "auto" && isInTelegramOrSafariIos) {
      if (wcConnectionPromise) {
        await wcConnectionPromise;
        wcConnectionPromise = void 0;
        return;
      }
      if (!CoreHelperUtil.isPairingExpired(state14 == null ? void 0 : state14.wcPairingExpiry)) {
        const link = state14.wcUri;
        state14.wcUri = link;
        return;
      }
      wcConnectionPromise = (_b = (_a = ConnectionController._getClient()) == null ? void 0 : _a.connectWalletConnect) == null ? void 0 : _b.call(_a).catch(() => void 0);
      ConnectionController.state.status = "connecting";
      await wcConnectionPromise;
      wcConnectionPromise = void 0;
      state14.wcPairingExpiry = void 0;
      ConnectionController.state.status = "connected";
    } else {
      await ((_d = (_c = ConnectionController._getClient()) == null ? void 0 : _c.connectWalletConnect) == null ? void 0 : _d.call(_c));
    }
  },
  async connectExternal(options, chain, setChain = true) {
    var _a, _b;
    const connectData = await ((_b = (_a = ConnectionController._getClient()) == null ? void 0 : _a.connectExternal) == null ? void 0 : _b.call(_a, options));
    if (setChain) {
      ChainController.setActiveNamespace(chain);
    }
    return connectData;
  },
  async reconnectExternal(options) {
    var _a, _b;
    await ((_b = (_a = ConnectionController._getClient()) == null ? void 0 : _a.reconnectExternal) == null ? void 0 : _b.call(_a, options));
    const namespace = options.chain || ChainController.state.activeChain;
    if (namespace) {
      ConnectorController.setConnectorId(options.id, namespace);
    }
  },
  async setPreferredAccountType(accountType, namespace) {
    var _a;
    if (!namespace) {
      return;
    }
    ModalController.setLoading(true, ChainController.state.activeChain);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    AccountController.setPreferredAccountType(accountType, namespace);
    await authConnector.provider.setPreferredAccount(accountType);
    StorageUtil.setPreferredAccountTypes(Object.entries(ChainController.state.chains).reduce((acc, [key, _]) => {
      const namespace2 = key;
      const accountType2 = getPreferredAccountType(namespace2);
      if (accountType2 !== void 0) {
        ;
        acc[namespace2] = accountType2;
      }
      return acc;
    }, {}));
    await ConnectionController.reconnectExternal(authConnector);
    ModalController.setLoading(false, ChainController.state.activeChain);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: {
        accountType,
        network: ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId) || ""
      }
    });
  },
  async signMessage(message) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.signMessage(message);
  },
  parseUnits(value, decimals) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.parseUnits(value, decimals);
  },
  formatUnits(value, decimals) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.formatUnits(value, decimals);
  },
  updateBalance(namespace) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.updateBalance(namespace);
  },
  async sendTransaction(args) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.sendTransaction(args);
  },
  async getCapabilities(params) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.getCapabilities(params);
  },
  async grantPermissions(params) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.grantPermissions(params);
  },
  async walletGetAssets(params) {
    var _a;
    return ((_a = ConnectionController._getClient()) == null ? void 0 : _a.walletGetAssets(params)) ?? {};
  },
  async estimateGas(args) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.estimateGas(args);
  },
  async writeContract(args) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.writeContract(args);
  },
  async getEnsAddress(value) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.getEnsAddress(value);
  },
  async getEnsAvatar(value) {
    var _a;
    return (_a = ConnectionController._getClient()) == null ? void 0 : _a.getEnsAvatar(value);
  },
  checkInstalled(ids) {
    var _a, _b;
    return ((_b = (_a = ConnectionController._getClient()) == null ? void 0 : _a.checkInstalled) == null ? void 0 : _b.call(_a, ids)) || false;
  },
  resetWcConnection() {
    state14.wcUri = void 0;
    state14.wcPairingExpiry = void 0;
    state14.wcLinking = void 0;
    state14.recentWallet = void 0;
    state14.status = "disconnected";
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  resetUri() {
    state14.wcUri = void 0;
    state14.wcPairingExpiry = void 0;
    wcConnectionPromise = void 0;
  },
  finalizeWcConnection(address) {
    var _a, _b;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    if (address) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        address,
        properties: {
          method: wcLinking ? "mobile" : "qrcode",
          name: ((_b = (_a = RouterController.state.data) == null ? void 0 : _a.wallet) == null ? void 0 : _b.name) || "Unknown"
        }
      });
    }
  },
  setWcBasic(wcBasic) {
    state14.wcBasic = wcBasic;
  },
  setUri(uri) {
    state14.wcUri = uri;
    state14.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
  },
  setWcLinking(wcLinking) {
    state14.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state14.wcError = wcError;
    state14.buffering = false;
  },
  setRecentWallet(wallet) {
    state14.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state14.buffering = buffering;
  },
  setStatus(status) {
    state14.status = status;
  },
  setIsSwitchingConnection(isSwitchingConnection) {
    state14.isSwitchingConnection = isSwitchingConnection;
  },
  async disconnect({ id, namespace, initialDisconnect } = {}) {
    var _a;
    try {
      await ((_a = ConnectionController._getClient()) == null ? void 0 : _a.disconnect({
        id,
        chainNamespace: namespace,
        initialDisconnect
      }));
    } catch (error) {
      throw new AppKitError("Failed to disconnect", "INTERNAL_SDK_ERROR", error);
    }
  },
  setConnections(connections, chainNamespace) {
    const connectionsMap = new Map(state14.connections);
    connectionsMap.set(chainNamespace, connections);
    state14.connections = connectionsMap;
  },
  async handleAuthAccountSwitch({ address, namespace }) {
    var _a, _b;
    const smartAccount = (_b = (_a = AccountController.state.user) == null ? void 0 : _a.accounts) == null ? void 0 : _b.find((c) => c.type === "smartAccount");
    const accountType = smartAccount && smartAccount.address.toLowerCase() === address.toLowerCase() && ConnectorControllerUtil.canSwitchToSmartAccount(namespace) ? "smartAccount" : "eoa";
    await ConnectionController.setPreferredAccountType(accountType, namespace);
  },
  async handleActiveConnection({ connection, namespace, address }) {
    const connector = ConnectorController.getConnectorById(connection.connectorId);
    const isAuthConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
    if (!connector) {
      throw new Error(`No connector found for connection: ${connection.connectorId}`);
    }
    if (!isAuthConnector) {
      const connectData = await ConnectionController.connectExternal({
        id: connector.id,
        type: connector.type,
        provider: connector.provider,
        address,
        chain: namespace
      }, namespace);
      return connectData == null ? void 0 : connectData.address;
    } else if (isAuthConnector && address) {
      await ConnectionController.handleAuthAccountSwitch({ address, namespace });
    }
    return address;
  },
  async handleDisconnectedConnection({ connection, namespace, address, closeModalOnConnect }) {
    var _a, _b;
    const connector = ConnectorController.getConnectorById(connection.connectorId);
    const authName = (_b = (_a = connection.auth) == null ? void 0 : _a.name) == null ? void 0 : _b.toLowerCase();
    const isAuthConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
    const isWCConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    if (!connector) {
      throw new Error(`No connector found for connection: ${connection.connectorId}`);
    }
    let newAddress = void 0;
    if (isAuthConnector) {
      if (authName && ConnectorControllerUtil.isSocialProvider(authName)) {
        const { address: socialAddress } = await ConnectorControllerUtil.connectSocial({
          social: authName,
          closeModalOnConnect,
          onOpenFarcaster() {
            ModalController.open({ view: "ConnectingFarcaster" });
          },
          onConnect() {
            RouterController.replace("ProfileWallets");
          }
        });
        newAddress = socialAddress;
      } else {
        const { address: emailAddress } = await ConnectorControllerUtil.connectEmail({
          closeModalOnConnect,
          onOpen() {
            ModalController.open({ view: "EmailLogin" });
          },
          onConnect() {
            RouterController.replace("ProfileWallets");
          }
        });
        newAddress = emailAddress;
      }
    } else if (isWCConnector) {
      const { address: wcAddress } = await ConnectorControllerUtil.connectWalletConnect({
        walletConnect: true,
        connector,
        closeModalOnConnect,
        onOpen(isMobile) {
          const view = isMobile ? "AllWallets" : "ConnectingWalletConnect";
          if (ModalController.state.open) {
            RouterController.push(view);
          } else {
            ModalController.open({ view });
          }
        },
        onConnect() {
          RouterController.replace("ProfileWallets");
        }
      });
      newAddress = wcAddress;
    } else {
      const connectData = await ConnectionController.connectExternal({
        id: connector.id,
        type: connector.type,
        provider: connector.provider,
        chain: namespace
      }, namespace);
      if (connectData) {
        newAddress = connectData.address;
      }
    }
    if (isAuthConnector && address) {
      await ConnectionController.handleAuthAccountSwitch({ address, namespace });
    }
    return newAddress;
  },
  async switchConnection({ connection, address, namespace, closeModalOnConnect, onChange }) {
    let currentAddress = void 0;
    const caipAddress = AccountController.getCaipAddress(namespace);
    if (caipAddress) {
      const { address: currentAddressParsed } = ParseUtil.parseCaipAddress(caipAddress);
      currentAddress = currentAddressParsed;
    }
    const status = ConnectionControllerUtil.getConnectionStatus(connection, namespace);
    switch (status) {
      case "connected":
      case "active": {
        const newAddress = await ConnectionController.handleActiveConnection({
          connection,
          namespace,
          address
        });
        if (currentAddress && newAddress) {
          const hasSwitchedAccount = newAddress.toLowerCase() !== currentAddress.toLowerCase();
          onChange == null ? void 0 : onChange({
            address: newAddress,
            namespace,
            hasSwitchedAccount,
            hasSwitchedWallet: status === "active"
          });
        }
        break;
      }
      case "disconnected": {
        const newAddress = await ConnectionController.handleDisconnectedConnection({
          connection,
          namespace,
          address,
          closeModalOnConnect
        });
        if (newAddress) {
          onChange == null ? void 0 : onChange({
            address: newAddress,
            namespace,
            hasSwitchedAccount: true,
            hasSwitchedWallet: true
          });
        }
        break;
      }
      default:
        throw new Error(`Invalid connection status: ${status}`);
    }
  }
};
var ConnectionController = withErrorBoundary(controller8);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SwapApiUtil.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);
var SwapApiUtil = {
  async getTokenList(caipNetworkId) {
    var _a;
    const response = await BlockchainApiController.fetchSwapTokens({
      chainId: caipNetworkId
    });
    const tokens = ((_a = response == null ? void 0 : response.tokens) == null ? void 0 : _a.map((token) => ({
      ...token,
      eip2612: false,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    }))) || [];
    return tokens;
  },
  async fetchGasPrice() {
    var _a, _b;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return null;
    }
    try {
      switch (caipNetwork.chainNamespace) {
        case "solana":
          const lamportsPerSignature = (_b = await ((_a = ConnectionController) == null ? void 0 : _a.estimateGas({ chainNamespace: "solana" }))) == null ? void 0 : _b.toString();
          return {
            standard: lamportsPerSignature,
            fast: lamportsPerSignature,
            instant: lamportsPerSignature
          };
        case "eip155":
        default:
          return await BlockchainApiController.fetchGasPrice({
            chainId: caipNetwork.caipNetworkId
          });
      }
    } catch {
      return null;
    }
  },
  async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
    const response = await BlockchainApiController.fetchSwapAllowance({
      tokenAddress,
      userAddress
    });
    if ((response == null ? void 0 : response.allowance) && sourceTokenAmount && sourceTokenDecimals) {
      const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals) || 0;
      const hasAllowance = BigInt(response.allowance) >= parsedValue;
      return hasAllowance;
    }
    return false;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await BalanceUtil.getMyTokensWithBalance(forceUpdate);
    AccountController.setTokenBalance(balances, ChainController.state.activeChain);
    return this.mapBalancesToSwapTokens(balances);
  },
  /**
   * Maps the balances from Blockchain API to SwapTokenWithBalance array
   * @param balances
   * @returns SwapTokenWithBalance[]
   */
  mapBalancesToSwapTokens(balances) {
    return (balances == null ? void 0 : balances.map((token) => ({
      ...token,
      address: (token == null ? void 0 : token.address) ? token.address : getActiveNetworkTokenAddress(),
      decimals: parseInt(token.quantity.decimals, 10),
      logoUri: token.iconUrl,
      eip2612: false
    }))) || [];
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js
var state15 = proxy({
  tokenBalances: [],
  loading: false
});
var controller9 = {
  state: state15,
  subscribe(callback) {
    return subscribe(state15, () => callback(state15));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state15, key, callback);
  },
  setToken(token) {
    if (token) {
      state15.token = ref(token);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state15.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state15.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state15.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state15.receiverProfileName = receiverProfileName;
  },
  setNetworkBalanceInUsd(networkBalanceInUSD) {
    state15.networkBalanceInUSD = networkBalanceInUSD;
  },
  setLoading(loading) {
    state15.loading = loading;
  },
  async sendToken() {
    var _a;
    try {
      SendController.setLoading(true);
      switch ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.chainNamespace) {
        case "eip155":
          await SendController.sendEvmToken();
          return;
        case "solana":
          await SendController.sendSolanaToken();
          return;
        default:
          throw new Error("Unsupported chain");
      }
    } finally {
      SendController.setLoading(false);
    }
  },
  async sendEvmToken() {
    var _a, _b, _c;
    const activeChainNamespace = ChainController.state.activeChain;
    if (!activeChainNamespace) {
      throw new Error("SendController:sendEvmToken - activeChainNamespace is required");
    }
    const activeAccountType = getPreferredAccountType(activeChainNamespace);
    if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
      throw new Error("An amount and receiver address are required");
    }
    if (!SendController.state.token) {
      throw new Error("A token is required");
    }
    if ((_a = SendController.state.token) == null ? void 0 : _a.address) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: activeAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: SendController.state.token.address,
          amount: SendController.state.sendTokenAmount,
          network: ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId) || ""
        }
      });
      const { hash } = await SendController.sendERC20Token({
        receiverAddress: SendController.state.receiverAddress,
        tokenAddress: SendController.state.token.address,
        sendTokenAmount: SendController.state.sendTokenAmount,
        decimals: SendController.state.token.quantity.decimals
      });
      if (hash) {
        state15.hash = hash;
      }
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: activeAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: SendController.state.token.symbol || "",
          amount: SendController.state.sendTokenAmount,
          network: ((_c = ChainController.state.activeCaipNetwork) == null ? void 0 : _c.caipNetworkId) || ""
        }
      });
      const { hash } = await SendController.sendNativeToken({
        receiverAddress: SendController.state.receiverAddress,
        sendTokenAmount: SendController.state.sendTokenAmount,
        decimals: SendController.state.token.quantity.decimals
      });
      if (hash) {
        state15.hash = hash;
      }
    }
  },
  async fetchTokenBalance(onError) {
    var _a, _b;
    state15.loading = true;
    const namespace = ChainController.state.activeChain;
    const chainId = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId;
    const chain = (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.chainNamespace;
    const caipAddress = AccountController.getCaipAddress(namespace) ?? ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state15.lastRetry && !CoreHelperUtil.isAllowedRetry(state15.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
      state15.loading = false;
      return [];
    }
    try {
      if (address && chainId && chain) {
        const balances = await BalanceUtil.getMyTokensWithBalance();
        state15.tokenBalances = balances;
        state15.lastRetry = void 0;
        return balances;
      }
    } catch (error) {
      state15.lastRetry = Date.now();
      onError == null ? void 0 : onError(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state15.loading = false;
    }
    return [];
  },
  fetchNetworkBalance() {
    if (state15.tokenBalances.length === 0) {
      return;
    }
    const networkTokenBalances = SwapApiUtil.mapBalancesToSwapTokens(state15.tokenBalances);
    if (!networkTokenBalances) {
      return;
    }
    const networkToken = networkTokenBalances.find((token) => token.address === getActiveNetworkTokenAddress());
    if (!networkToken) {
      return;
    }
    state15.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async sendNativeToken(params) {
    var _a, _b, _c;
    RouterController.pushTransactionStack({});
    const to = params.receiverAddress;
    const address = AccountController.state.address;
    const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    const data = "0x";
    const hash = await ConnectionController.sendTransaction({
      chainNamespace: ConstantsUtil.CHAIN.EVM,
      to,
      address,
      data,
      value: value ?? BigInt(0)
    });
    EventsController.sendEvent({
      type: "track",
      event: "SEND_SUCCESS",
      properties: {
        isSmartAccount: getPreferredAccountType("eip155") === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
        token: ((_a = SendController.state.token) == null ? void 0 : _a.symbol) || "",
        amount: params.sendTokenAmount,
        network: ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId) || "",
        hash: hash || ""
      }
    });
    (_c = ConnectionController._getClient()) == null ? void 0 : _c.updateBalance("eip155");
    SendController.resetSend();
    return { hash };
  },
  async sendERC20Token(params) {
    var _a, _b;
    RouterController.pushTransactionStack({
      onSuccess() {
        RouterController.replace("Account");
      }
    });
    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
      const tokenAddress = CoreHelperUtil.getPlainAddress(params.tokenAddress);
      if (!tokenAddress) {
        throw new Error("SendController:sendERC20Token - tokenAddress is required");
      }
      const hash = await ConnectionController.writeContract({
        fromAddress: AccountController.state.address,
        tokenAddress,
        args: [params.receiverAddress, amount ?? BigInt(0)],
        method: "transfer",
        abi: ContractUtil.getERC20Abi(tokenAddress),
        chainNamespace: ConstantsUtil.CHAIN.EVM
      });
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: getPreferredAccountType("eip155") === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_a = SendController.state.token) == null ? void 0 : _a.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId) || "",
          hash: hash || ""
        }
      });
      SendController.resetSend();
      return { hash };
    }
    return { hash: void 0 };
  },
  async sendSolanaToken() {
    var _a;
    if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
      throw new Error("An amount and receiver address are required");
    }
    RouterController.pushTransactionStack({
      onSuccess() {
        RouterController.replace("Account");
      }
    });
    let tokenMint = void 0;
    if (SendController.state.token && SendController.state.token.address !== ConstantsUtil2.SOLANA_NATIVE_TOKEN_ADDRESS) {
      if (CoreHelperUtil.isCaipAddress(SendController.state.token.address)) {
        tokenMint = CoreHelperUtil.getPlainAddress(SendController.state.token.address);
      } else {
        tokenMint = SendController.state.token.address;
      }
    }
    const hash = await ConnectionController.sendTransaction({
      chainNamespace: "solana",
      tokenMint,
      to: SendController.state.receiverAddress,
      value: SendController.state.sendTokenAmount
    });
    if (hash) {
      state15.hash = hash;
    }
    (_a = ConnectionController._getClient()) == null ? void 0 : _a.updateBalance("solana");
    SendController.resetSend();
  },
  resetSend() {
    state15.token = void 0;
    state15.sendTokenAmount = void 0;
    state15.receiverAddress = void 0;
    state15.receiverProfileImageUrl = void 0;
    state15.receiverProfileName = void 0;
    state15.loading = false;
    state15.tokenBalances = [];
  }
};
var SendController = withErrorBoundary(controller9);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var accountState = {
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  user: void 0,
  preferredAccountType: void 0
};
var networkState = {
  caipNetwork: void 0,
  supportsAllNetworks: true,
  smartAccountEnabledNetworks: []
};
var state16 = proxy({
  chains: proxyMap(),
  activeCaipAddress: void 0,
  activeChain: void 0,
  activeCaipNetwork: void 0,
  noAdapters: false,
  universalAdapter: {
    networkControllerClient: void 0,
    connectionControllerClient: void 0
  },
  isSwitchingNamespace: false
});
var controller10 = {
  state: state16,
  subscribe(callback) {
    return subscribe(state16, () => {
      callback(state16);
    });
  },
  subscribeKey(key, callback) {
    return subscribeKey(state16, key, callback);
  },
  subscribeChainProp(property, callback, chain) {
    let prev = void 0;
    return subscribe(state16.chains, () => {
      var _a;
      const activeChain = chain || state16.activeChain;
      if (activeChain) {
        const nextValue = (_a = state16.chains.get(activeChain)) == null ? void 0 : _a[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  initialize(adapters, caipNetworks, clients) {
    const { chainId: activeChainId, namespace: activeNamespace } = StorageUtil.getActiveNetworkProps();
    const activeCaipNetwork = caipNetworks == null ? void 0 : caipNetworks.find((network) => network.id.toString() === (activeChainId == null ? void 0 : activeChainId.toString()));
    const defaultAdapter = adapters.find((adapter) => (adapter == null ? void 0 : adapter.namespace) === activeNamespace);
    const adapterToActivate = defaultAdapter || (adapters == null ? void 0 : adapters[0]);
    const namespacesFromAdapters = adapters.map((a) => a.namespace).filter((n) => n !== void 0);
    const namespaces = OptionsController.state.enableEmbedded ? /* @__PURE__ */ new Set([...namespacesFromAdapters]) : /* @__PURE__ */ new Set([...(caipNetworks == null ? void 0 : caipNetworks.map((network) => network.chainNamespace)) ?? []]);
    if ((adapters == null ? void 0 : adapters.length) === 0 || !adapterToActivate) {
      state16.noAdapters = true;
    }
    if (!state16.noAdapters) {
      state16.activeChain = adapterToActivate == null ? void 0 : adapterToActivate.namespace;
      state16.activeCaipNetwork = activeCaipNetwork;
      ChainController.setChainNetworkData(adapterToActivate == null ? void 0 : adapterToActivate.namespace, {
        caipNetwork: activeCaipNetwork
      });
      if (state16.activeChain) {
        PublicStateController.set({ activeChain: adapterToActivate == null ? void 0 : adapterToActivate.namespace });
      }
    }
    namespaces.forEach((namespace) => {
      const namespaceNetworks = caipNetworks == null ? void 0 : caipNetworks.filter((network) => network.chainNamespace === namespace);
      const storedAccountTypes = StorageUtil.getPreferredAccountTypes() || {};
      const defaultTypes = { ...OptionsController.state.defaultAccountTypes, ...storedAccountTypes };
      ChainController.state.chains.set(namespace, {
        namespace,
        networkState: proxy({ ...networkState, caipNetwork: namespaceNetworks == null ? void 0 : namespaceNetworks[0] }),
        accountState: proxy({ ...accountState, preferredAccountType: defaultTypes[namespace] }),
        caipNetworks: namespaceNetworks ?? [],
        ...clients
      });
      ChainController.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);
    });
  },
  removeAdapter(namespace) {
    var _a, _b;
    if (state16.activeChain === namespace) {
      const nextAdapter = Array.from(state16.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);
      if (nextAdapter) {
        const caipNetwork = (_b = (_a = nextAdapter[1]) == null ? void 0 : _a.caipNetworks) == null ? void 0 : _b[0];
        if (caipNetwork) {
          ChainController.setActiveCaipNetwork(caipNetwork);
        }
      }
    }
    state16.chains.delete(namespace);
  },
  addAdapter(adapter, { networkControllerClient, connectionControllerClient }, caipNetworks) {
    if (!adapter.namespace) {
      throw new Error("ChainController:addAdapter - adapter must have a namespace");
    }
    state16.chains.set(adapter.namespace, {
      namespace: adapter.namespace,
      networkState: { ...networkState, caipNetwork: caipNetworks[0] },
      accountState,
      caipNetworks,
      connectionControllerClient,
      networkControllerClient
    });
    ChainController.setRequestedCaipNetworks((caipNetworks == null ? void 0 : caipNetworks.filter((caipNetwork) => caipNetwork.chainNamespace === adapter.namespace)) ?? [], adapter.namespace);
  },
  addNetwork(network) {
    var _a;
    const chainAdapter = state16.chains.get(network.chainNamespace);
    if (chainAdapter) {
      const newNetworks = [...chainAdapter.caipNetworks || []];
      if (!((_a = chainAdapter.caipNetworks) == null ? void 0 : _a.find((caipNetwork) => caipNetwork.id === network.id))) {
        newNetworks.push(network);
      }
      state16.chains.set(network.chainNamespace, { ...chainAdapter, caipNetworks: newNetworks });
      ChainController.setRequestedCaipNetworks(newNetworks, network.chainNamespace);
      ConnectorController.filterByNamespace(network.chainNamespace, true);
    }
  },
  removeNetwork(namespace, networkId) {
    var _a, _b, _c;
    const chainAdapter = state16.chains.get(namespace);
    if (chainAdapter) {
      const isActiveNetwork = ((_a = state16.activeCaipNetwork) == null ? void 0 : _a.id) === networkId;
      const newCaipNetworksOfAdapter = [
        ...((_b = chainAdapter.caipNetworks) == null ? void 0 : _b.filter((network) => network.id !== networkId)) || []
      ];
      if (isActiveNetwork && ((_c = chainAdapter == null ? void 0 : chainAdapter.caipNetworks) == null ? void 0 : _c[0])) {
        ChainController.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);
      }
      state16.chains.set(namespace, { ...chainAdapter, caipNetworks: newCaipNetworksOfAdapter });
      ChainController.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);
      if (newCaipNetworksOfAdapter.length === 0) {
        ConnectorController.filterByNamespace(namespace, false);
      }
    }
  },
  setAdapterNetworkState(chain, props) {
    const chainAdapter = state16.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.networkState = {
        ...chainAdapter.networkState || networkState,
        ...props
      };
      state16.chains.set(chain, chainAdapter);
    }
  },
  setChainAccountData(chain, accountProps, _unknown = true) {
    if (!chain) {
      throw new Error("Chain is required to update chain account data");
    }
    const chainAdapter = state16.chains.get(chain);
    if (chainAdapter) {
      const newAccountState = { ...chainAdapter.accountState || accountState, ...accountProps };
      state16.chains.set(chain, { ...chainAdapter, accountState: newAccountState });
      if (state16.chains.size === 1 || state16.activeChain === chain) {
        if (accountProps.caipAddress) {
          state16.activeCaipAddress = accountProps.caipAddress;
        }
        AccountController.replaceState(newAccountState);
      }
    }
  },
  setChainNetworkData(chain, networkProps) {
    if (!chain) {
      return;
    }
    const chainAdapter = state16.chains.get(chain);
    if (chainAdapter) {
      const newNetworkState = { ...chainAdapter.networkState || networkState, ...networkProps };
      state16.chains.set(chain, { ...chainAdapter, networkState: newNetworkState });
    }
  },
  // eslint-disable-next-line max-params
  setAccountProp(prop, value, chain, replaceState = true) {
    ChainController.setChainAccountData(chain, { [prop]: value }, replaceState);
  },
  setActiveNamespace(chain) {
    var _a, _b;
    state16.activeChain = chain;
    const newAdapter = chain ? state16.chains.get(chain) : void 0;
    const caipNetwork = (_a = newAdapter == null ? void 0 : newAdapter.networkState) == null ? void 0 : _a.caipNetwork;
    if ((caipNetwork == null ? void 0 : caipNetwork.id) && chain) {
      state16.activeCaipAddress = (_b = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _b.caipAddress;
      state16.activeCaipNetwork = caipNetwork;
      ChainController.setChainNetworkData(chain, { caipNetwork });
      StorageUtil.setActiveCaipNetworkId(caipNetwork == null ? void 0 : caipNetwork.caipNetworkId);
      PublicStateController.set({
        activeChain: chain,
        selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.caipNetworkId
      });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    var _a, _b, _c;
    if (!caipNetwork) {
      return;
    }
    if (state16.activeChain !== caipNetwork.chainNamespace) {
      ChainController.setIsSwitchingNamespace(true);
    }
    const newAdapter = state16.chains.get(caipNetwork.chainNamespace);
    state16.activeChain = caipNetwork.chainNamespace;
    state16.activeCaipNetwork = caipNetwork;
    ChainController.setChainNetworkData(caipNetwork.chainNamespace, { caipNetwork });
    if ((_a = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _a.address) {
      state16.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${(_b = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _b.address}`;
    } else {
      state16.activeCaipAddress = void 0;
    }
    ChainController.setAccountProp("caipAddress", state16.activeCaipAddress, caipNetwork.chainNamespace);
    if (newAdapter) {
      AccountController.replaceState(newAdapter.accountState);
    }
    SendController.resetSend();
    PublicStateController.set({
      activeChain: state16.activeChain,
      selectedNetworkId: (_c = state16.activeCaipNetwork) == null ? void 0 : _c.caipNetworkId
    });
    StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
    const isSupported = ChainController.checkIfSupportedNetwork(caipNetwork.chainNamespace);
    if (!isSupported && OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && !ConnectionController.state.wcBasic) {
      ChainController.showUnsupportedChainUI();
    }
  },
  addCaipNetwork(caipNetwork) {
    var _a;
    if (!caipNetwork) {
      return;
    }
    const chain = state16.chains.get(caipNetwork.chainNamespace);
    if (chain) {
      (_a = chain == null ? void 0 : chain.caipNetworks) == null ? void 0 : _a.push(caipNetwork);
    }
  },
  async switchActiveNamespace(namespace) {
    var _a;
    if (!namespace) {
      return;
    }
    const isDifferentChain = namespace !== ChainController.state.activeChain;
    const caipNetworkOfNamespace = (_a = ChainController.getNetworkData(namespace)) == null ? void 0 : _a.caipNetwork;
    const firstNetworkWithChain = ChainController.getCaipNetworkByNamespace(namespace, caipNetworkOfNamespace == null ? void 0 : caipNetworkOfNamespace.id);
    if (isDifferentChain && firstNetworkWithChain) {
      await ChainController.switchActiveNetwork(firstNetworkWithChain);
    }
  },
  async switchActiveNetwork(network, { throwOnFailure = false } = {}) {
    var _a;
    const namespace = ChainController.state.activeChain;
    if (!namespace) {
      throw new Error("ChainController:switchActiveNetwork - namespace is required");
    }
    const activeAdapter = ChainController.state.chains.get(namespace);
    const unsupportedNetwork = !((_a = activeAdapter == null ? void 0 : activeAdapter.caipNetworks) == null ? void 0 : _a.some((caipNetwork) => {
      var _a2;
      return caipNetwork.id === ((_a2 = state16.activeCaipNetwork) == null ? void 0 : _a2.id);
    }));
    const networkControllerClient = ChainController.getNetworkControllerClient(network.chainNamespace);
    if (networkControllerClient) {
      try {
        await networkControllerClient.switchCaipNetwork(network);
        if (unsupportedNetwork) {
          ModalController.close();
        }
      } catch (error) {
        if (throwOnFailure) {
          throw error;
        }
        RouterController.goBack();
      }
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.caipNetworkId }
      });
    }
  },
  getNetworkControllerClient(chainNamespace) {
    const chain = chainNamespace || state16.activeChain;
    if (!chain) {
      throw new Error("ChainController:getNetworkControllerClient - chain is required");
    }
    const chainAdapter = state16.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.networkControllerClient) {
      throw new Error("NetworkController client not set");
    }
    return chainAdapter.networkControllerClient;
  },
  getConnectionControllerClient(_chain) {
    const chain = _chain || state16.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get connection controller client");
    }
    const chainAdapter = state16.chains.get(chain);
    if (!(chainAdapter == null ? void 0 : chainAdapter.connectionControllerClient)) {
      throw new Error("ConnectionController client not set");
    }
    return chainAdapter.connectionControllerClient;
  },
  getNetworkProp(key, namespace) {
    var _a;
    const chainNetworkState = (_a = state16.chains.get(namespace)) == null ? void 0 : _a.networkState;
    if (!chainNetworkState) {
      return void 0;
    }
    return chainNetworkState[key];
  },
  getRequestedCaipNetworks(chainToFilter) {
    const adapter = state16.chains.get(chainToFilter);
    const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = (adapter == null ? void 0 : adapter.networkState) || {};
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = sortedNetworks.filter((network) => network == null ? void 0 : network.id);
    return filteredNetworks;
  },
  getAllRequestedCaipNetworks() {
    const requestedCaipNetworks = [];
    state16.chains.forEach((chainAdapter) => {
      if (!chainAdapter.namespace) {
        throw new Error("ChainController:getAllRequestedCaipNetworks - chainAdapter must have a namespace");
      }
      const caipNetworks = ChainController.getRequestedCaipNetworks(chainAdapter.namespace);
      requestedCaipNetworks.push(...caipNetworks);
    });
    return requestedCaipNetworks;
  },
  setRequestedCaipNetworks(caipNetworks, chain) {
    ChainController.setAdapterNetworkState(chain, { requestedCaipNetworks: caipNetworks });
    const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const namespaces = allRequestedCaipNetworks.map((network) => network.chainNamespace);
    const uniqueNamespaces = Array.from(new Set(namespaces));
    ConnectorController.filterByNamespaces(uniqueNamespaces);
  },
  getAllApprovedCaipNetworkIds() {
    const approvedCaipNetworkIds = [];
    state16.chains.forEach((chainAdapter) => {
      if (!chainAdapter.namespace) {
        throw new Error("ChainController:getAllApprovedCaipNetworkIds - chainAdapter must have a namespace");
      }
      const approvedIds = ChainController.getApprovedCaipNetworkIds(chainAdapter.namespace);
      approvedCaipNetworkIds.push(...approvedIds);
    });
    return approvedCaipNetworkIds;
  },
  getActiveCaipNetwork(chainNamespace) {
    var _a, _b;
    if (chainNamespace) {
      return (_b = (_a = state16.chains.get(chainNamespace)) == null ? void 0 : _a.networkState) == null ? void 0 : _b.caipNetwork;
    }
    return state16.activeCaipNetwork;
  },
  getActiveCaipAddress() {
    return state16.activeCaipAddress;
  },
  getApprovedCaipNetworkIds(namespace) {
    var _a;
    const adapter = state16.chains.get(namespace);
    const approvedCaipNetworkIds = ((_a = adapter == null ? void 0 : adapter.networkState) == null ? void 0 : _a.approvedCaipNetworkIds) || [];
    return approvedCaipNetworkIds;
  },
  async setApprovedCaipNetworksData(namespace) {
    const networkControllerClient = ChainController.getNetworkControllerClient();
    const data = await (networkControllerClient == null ? void 0 : networkControllerClient.getApprovedCaipNetworksData());
    ChainController.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: data == null ? void 0 : data.approvedCaipNetworkIds,
      supportsAllNetworks: data == null ? void 0 : data.supportsAllNetworks
    });
  },
  checkIfSupportedNetwork(namespace, caipNetworkId) {
    var _a;
    const activeCaipNetworkId = caipNetworkId || ((_a = state16.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(namespace);
    if (!requestedCaipNetworks.length) {
      return true;
    }
    return requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.some((network) => network.caipNetworkId === activeCaipNetworkId);
  },
  checkIfSupportedChainId(chainId) {
    if (!state16.activeChain) {
      return true;
    }
    const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(state16.activeChain);
    return requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.some((network) => network.id === chainId);
  },
  // Smart Account Network Handlers
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
    ChainController.setAdapterNetworkState(chain, { smartAccountEnabledNetworks });
  },
  checkIfSmartAccountEnabled() {
    var _a;
    const networkId = NetworkUtil.caipNetworkIdToNumber((_a = state16.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    const activeChain = state16.activeChain;
    if (!activeChain || !networkId) {
      return false;
    }
    const smartAccountEnabledNetworks = ChainController.getNetworkProp("smartAccountEnabledNetworks", activeChain);
    return Boolean(smartAccountEnabledNetworks == null ? void 0 : smartAccountEnabledNetworks.includes(Number(networkId)));
  },
  showUnsupportedChainUI() {
    ModalController.open({ view: "UnsupportedChain" });
  },
  checkIfNamesSupported() {
    const activeCaipNetwork = state16.activeCaipNetwork;
    return Boolean((activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace) && ConstantsUtil2.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
  },
  resetNetwork(namespace) {
    ChainController.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: true
    });
  },
  resetAccount(chain) {
    var _a, _b;
    const chainToWrite = chain;
    if (!chainToWrite) {
      throw new Error("Chain is required to set account prop");
    }
    const currentAccountType = (_b = (_a = ChainController.state.chains.get(chainToWrite)) == null ? void 0 : _a.accountState) == null ? void 0 : _b.preferredAccountType;
    const optionsAccountType = OptionsController.state.defaultAccountTypes[chainToWrite];
    state16.activeCaipAddress = void 0;
    ChainController.setChainAccountData(chainToWrite, {
      smartAccountDeployed: false,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountType: optionsAccountType || currentAccountType,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0,
      user: void 0,
      status: "disconnected"
    });
    ConnectorController.removeConnectorId(chainToWrite);
  },
  setIsSwitchingNamespace(isSwitchingNamespace) {
    state16.isSwitchingNamespace = isSwitchingNamespace;
  },
  getFirstCaipNetworkSupportsAuthConnector() {
    var _a, _b;
    const availableChains = [];
    let firstCaipNetwork = void 0;
    state16.chains.forEach((chain) => {
      if (ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((ns) => ns === chain.namespace)) {
        if (chain.namespace) {
          availableChains.push(chain.namespace);
        }
      }
    });
    if (availableChains.length > 0) {
      const firstAvailableChain = availableChains[0];
      firstCaipNetwork = firstAvailableChain ? (_b = (_a = state16.chains.get(firstAvailableChain)) == null ? void 0 : _a.caipNetworks) == null ? void 0 : _b[0] : void 0;
      return firstCaipNetwork;
    }
    return void 0;
  },
  getAccountData(chainNamespace) {
    var _a;
    const namespace = chainNamespace || state16.activeChain;
    if (!namespace) {
      return void 0;
    }
    return (_a = ChainController.state.chains.get(namespace)) == null ? void 0 : _a.accountState;
  },
  getNetworkData(chainNamespace) {
    var _a;
    const namespace = chainNamespace || state16.activeChain;
    if (!namespace) {
      return void 0;
    }
    return (_a = ChainController.state.chains.get(namespace)) == null ? void 0 : _a.networkState;
  },
  getCaipNetworkByNamespace(chainNamespace, chainId) {
    var _a, _b, _c;
    if (!chainNamespace) {
      return void 0;
    }
    const chain = ChainController.state.chains.get(chainNamespace);
    const byChainId = (_a = chain == null ? void 0 : chain.caipNetworks) == null ? void 0 : _a.find((network) => network.id === chainId);
    if (byChainId) {
      return byChainId;
    }
    return ((_b = chain == null ? void 0 : chain.networkState) == null ? void 0 : _b.caipNetwork) || ((_c = chain == null ? void 0 : chain.caipNetworks) == null ? void 0 : _c[0]);
  },
  /**
   * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned
   * @param namespace - The namespace to get the requested CaipNetwork IDs for
   * @returns The requested CaipNetwork IDs
   */
  getRequestedCaipNetworkIds() {
    const namespace = ConnectorController.state.filterByNamespace;
    const chains = namespace ? [state16.chains.get(namespace)] : Array.from(state16.chains.values());
    return chains.flatMap((chain) => (chain == null ? void 0 : chain.caipNetworks) || []).map((caipNetwork) => caipNetwork.caipNetworkId);
  },
  getCaipNetworks(namespace) {
    if (namespace) {
      return ChainController.getRequestedCaipNetworks(namespace);
    }
    return ChainController.getAllRequestedCaipNetworks();
  },
  getCaipNetworkById(id, namespace) {
    return controller10.getCaipNetworks(namespace).find((n) => n.id.toString() === id.toString() || n.caipNetworkId.toString() === id.toString());
  },
  setLastConnectedSIWECaipNetwork(network) {
    state16.lastConnectedSIWECaipNetwork = network;
  },
  getLastConnectedSIWECaipNetwork() {
    return state16.lastConnectedSIWECaipNetwork;
  }
};
var ChainController = withErrorBoundary(controller10);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
var baseUrl3 = CoreHelperUtil.getBlockchainApiUrl();
var state17 = proxy({
  clientId: null,
  api: new FetchUtil({ baseUrl: baseUrl3, clientId: null }),
  supportedChains: { http: [], ws: [] }
});
var BlockchainApiController = {
  state: state17,
  async get(request) {
    const { st, sv } = BlockchainApiController.getSdkProperties();
    const projectId = OptionsController.state.projectId;
    const params = {
      ...request.params || {},
      st,
      sv,
      projectId
    };
    return state17.api.get({
      ...request,
      params
    });
  },
  getSdkProperties() {
    const { sdkType, sdkVersion } = OptionsController.state;
    return {
      st: sdkType || "unknown",
      sv: sdkVersion || "unknown"
    };
  },
  async isNetworkSupported(networkId) {
    if (!networkId) {
      return false;
    }
    try {
      if (!state17.supportedChains.http.length) {
        await BlockchainApiController.getSupportedNetworks();
      }
    } catch (e) {
      return false;
    }
    return state17.supportedChains.http.includes(networkId);
  },
  async getSupportedNetworks() {
    try {
      const supportedChains = await BlockchainApiController.get({
        path: "v1/supported-chains"
      });
      state17.supportedChains = supportedChains;
      return supportedChains;
    } catch {
      return state17.supportedChains;
    }
  },
  async fetchIdentity({ address }) {
    const identityCache = StorageUtil.getIdentityFromCacheForAddress(address);
    if (identityCache) {
      return identityCache;
    }
    const result = await BlockchainApiController.get({
      path: `/v1/identity/${address}`,
      params: {
        sender: ChainController.state.activeCaipAddress ? CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress) : void 0
      }
    });
    StorageUtil.updateIdentityCache({
      address,
      identity: result,
      timestamp: Date.now()
    });
    return result;
  },
  async fetchTransactions({ account, cursor, signal, cache, chainId }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { data: [], next: void 0 };
    }
    const transactionsCache = StorageUtil.getTransactionsCacheForAddress({
      address: account,
      chainId
    });
    if (transactionsCache) {
      return transactionsCache;
    }
    const result = await BlockchainApiController.get({
      path: `/v1/account/${account}/history`,
      params: {
        cursor,
        chainId
      },
      signal,
      cache
    });
    StorageUtil.updateTransactionsCache({
      address: account,
      chainId,
      timestamp: Date.now(),
      transactions: result
    });
    return result;
  },
  async fetchSwapQuote({ amount, userAddress, from, to, gasPrice }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { quotes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        amount,
        userAddress,
        from,
        to,
        gasPrice
      }
    });
  },
  async fetchSwapTokens({ chainId }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { tokens: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/tokens`,
      params: { chainId }
    });
  },
  async fetchTokenPrice({ addresses }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { fungibles: [] };
    }
    const tokenPriceCache = StorageUtil.getTokenPriceCacheForAddresses(addresses);
    if (tokenPriceCache) {
      return tokenPriceCache;
    }
    const result = await state17.api.post({
      path: "/v1/fungible/price",
      body: {
        currency: "usd",
        addresses,
        projectId: OptionsController.state.projectId
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
    StorageUtil.updateTokenPriceCache({
      addresses,
      timestamp: Date.now(),
      tokenPrice: result
    });
    return result;
  },
  async fetchSwapAllowance({ tokenAddress, userAddress }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { allowance: "0" };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/allowance`,
      params: {
        tokenAddress,
        userAddress
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async fetchGasPrice({ chainId }) {
    var _a;
    const { st, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Gas Price");
    }
    return BlockchainApiController.get({
      path: `/v1/convert/gas-price`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        chainId,
        st,
        sv
      }
    });
  },
  async generateSwapCalldata({ amount, from, to, userAddress, disableEstimate }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return state17.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE
        },
        projectId: OptionsController.state.projectId,
        from,
        to,
        userAddress,
        disableEstimate
      }
    });
  },
  async generateApproveCalldata({ from, to, userAddress }) {
    var _a;
    const { st, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return BlockchainApiController.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        userAddress,
        from,
        to,
        st,
        sv
      }
    });
  },
  async getBalance(address, chainId, forceUpdate) {
    var _a;
    const { st, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      SnackController.showError("Token Balance Unavailable");
      return { balances: [] };
    }
    const caipAddress = `${chainId}:${address}`;
    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
    if (cachedBalance) {
      return cachedBalance;
    }
    const balance = await BlockchainApiController.get({
      path: `/v1/account/${address}/balance`,
      params: {
        currency: "usd",
        chainId,
        forceUpdate,
        st,
        sv
      }
    });
    StorageUtil.updateBalanceCache({
      caipAddress,
      balance,
      timestamp: Date.now()
    });
    return balance;
  },
  async lookupEnsName(name) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { addresses: {}, attributes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/account/${name}`,
      params: { apiVersion: "2" }
    });
  },
  async reverseLookupEnsName({ address }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/profile/reverse/${address}`,
      params: {
        sender: AccountController.state.address,
        apiVersion: "2"
      }
    });
  },
  async getEnsNameSuggestions(name) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { suggestions: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/suggestions/${name}`,
      params: { zone: "reown.id" }
    });
  },
  async registerEnsName({ coinType, address, message, signature }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state17.api.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return "";
    }
    const response = await state17.api.post({
      path: `/v1/generators/onrampurl`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { paymentCurrencies: [], purchaseCurrencies: [] };
    }
    try {
      const response = await BlockchainApiController.get({
        path: `/v1/onramp/options`
      });
      return response;
    } catch (e) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    var _a;
    try {
      const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
      if (!isSupported) {
        return null;
      }
      const response = await state17.api.post({
        path: `/v1/onramp/quote`,
        params: {
          projectId: OptionsController.state.projectId
        },
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e) {
      return {
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  async getSmartSessions(caipAddress) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/sessions/${caipAddress}`
    });
  },
  async revokeSmartSession(address, pci, signature) {
    var _a;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state17.api.post({
      path: `/v1/sessions/${address}/revoke`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        pci,
        signature
      }
    });
  },
  setClientId(clientId) {
    state17.clientId = clientId;
    state17.api = new FetchUtil({ baseUrl: baseUrl3, clientId });
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ERC7811Util.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);
var ERC7811Utils = {
  /**
   * Creates a Balance object from an ERC7811 Asset object
   * @param asset - Asset object to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns Balance object
   */
  createBalance(asset, chainId) {
    const metadata = {
      name: asset.metadata["name"] || "",
      symbol: asset.metadata["symbol"] || "",
      decimals: asset.metadata["decimals"] || 0,
      value: asset.metadata["value"] || 0,
      price: asset.metadata["price"] || 0,
      iconUrl: asset.metadata["iconUrl"] || ""
    };
    return {
      name: metadata.name,
      symbol: metadata.symbol,
      chainId,
      address: asset.address === "native" ? void 0 : this.convertAddressToCAIP10Address(asset.address, chainId),
      value: metadata.value,
      price: metadata.price,
      quantity: {
        decimals: metadata.decimals.toString(),
        numeric: this.convertHexToBalance({
          hex: asset.balance,
          decimals: metadata.decimals
        })
      },
      iconUrl: metadata.iconUrl
    };
  },
  /**
   * Converts a hex string to a Balance object
   * @param hex - Hex string to convert
   * @param decimals - Number of decimals to use
   * @returns Balance object
   */
  convertHexToBalance({ hex, decimals }) {
    return formatUnits(BigInt(hex), decimals);
  },
  /**
   * Converts an address to a CAIP-10 address
   * @param address - Address to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns CAIP-10 address
   */
  convertAddressToCAIP10Address(address, chainId) {
    return `${chainId}:${address}`;
  },
  /**
   *  Creates a CAIP-2 Chain ID from a chain ID and namespace
   * @param chainId  - Chain ID in hex format
   * @param namespace  - Chain namespace
   * @returns
   */
  createCAIP2ChainId(chainId, namespace) {
    return `${namespace}:${parseInt(chainId, 16)}`;
  },
  /**
   * Gets the chain ID in hex format from a CAIP-2 Chain ID
   * @param caip2ChainId - CAIP-2 Chain ID
   * @returns Chain ID in hex format
   */
  getChainIdHexFromCAIP2ChainId(caip2ChainId) {
    const parts = caip2ChainId.split(":");
    if (parts.length < 2 || !parts[1]) {
      return "0x0";
    }
    const chainPart = parts[1];
    const parsed = parseInt(chainPart, 10);
    return isNaN(parsed) ? "0x0" : `0x${parsed.toString(16)}`;
  },
  /**
   * Checks if a response is a valid WalletGetAssetsResponse
   * @param response - The response to check
   * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
   */
  isWalletGetAssetsResponse(response) {
    if (typeof response !== "object" || response === null) {
      return false;
    }
    return Object.values(response).every((value) => Array.isArray(value) && value.every((asset) => this.isValidAsset(asset)));
  },
  /**
   * Checks if an asset object is valid.
   * @param asset - The asset object to check.
   * @returns True if the asset is valid, false otherwise.
   */
  isValidAsset(asset) {
    return typeof asset === "object" && asset !== null && typeof asset.address === "string" && typeof asset.balance === "string" && (asset.type === "ERC20" || asset.type === "NATIVE") && typeof asset.metadata === "object" && asset.metadata !== null && typeof asset.metadata["name"] === "string" && typeof asset.metadata["symbol"] === "string" && typeof asset.metadata["decimals"] === "number" && typeof asset.metadata["price"] === "number" && typeof asset.metadata["iconUrl"] === "string";
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ViemUtil.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var cachedViemUtils = void 0;
async function loadViemUtils() {
  if (!cachedViemUtils) {
    const { createPublicClient, http, defineChain } = await import("./_esm-WQ56IPG2.js");
    cachedViemUtils = {
      createPublicClient,
      http,
      defineChain
    };
  }
  return cachedViemUtils;
}
var ViemUtil = {
  getBlockchainApiRpcUrl(caipNetworkId, projectId) {
    const url = new URL("https://rpc.walletconnect.org/v1/");
    url.searchParams.set("chainId", caipNetworkId);
    url.searchParams.set("projectId", projectId);
    return url.toString();
  },
  async getViemChain(caipNetwork) {
    const { defineChain } = await loadViemUtils();
    const { chainId } = ParseUtil.parseCaipNetworkId(caipNetwork.caipNetworkId);
    return defineChain({ ...caipNetwork, id: Number(chainId) });
  },
  async createViemPublicClient(caipNetwork) {
    const { createPublicClient, http } = await loadViemUtils();
    const projectId = OptionsController.state.projectId;
    const viemChain = await ViemUtil.getViemChain(caipNetwork);
    if (!viemChain) {
      throw new Error(`Chain ${caipNetwork.caipNetworkId} not found in viem/chains`);
    }
    return createPublicClient({
      chain: viemChain,
      transport: http(ViemUtil.getBlockchainApiRpcUrl(caipNetwork.caipNetworkId, projectId))
    });
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/BalanceUtil.js
var BalanceUtil = {
  /**
   * Get the balances of the user's tokens. If user connected with Auth provider or and on the EIP155 network,
   * it'll use the `wallet_getAssets` and `wallet_getCapabilities` calls to fetch the balance rather than Blockchain API
   * @param forceUpdate - If true, the balances will be fetched from the server
   * @returns The balances of the user's tokens
   */
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const isAuthConnector = ConnectorController.getConnectorId("eip155") === ConstantsUtil.CONNECTOR_ID.AUTH;
    if (!address || !caipNetwork) {
      return [];
    }
    const caipAddress = `${caipNetwork.caipNetworkId}:${address}`;
    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
    if (cachedBalance) {
      return cachedBalance.balances;
    }
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM && isAuthConnector) {
      const eip155Balances = await this.getEIP155Balances(address, caipNetwork);
      if (eip155Balances) {
        return this.filterLowQualityTokens(eip155Balances);
      }
    }
    const response = await BlockchainApiController.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);
    return this.filterLowQualityTokens(response.balances);
  },
  /**
   * Get the balances of the user's tokens on the EIP155 network using native `wallet_getAssets` and `wallet_getCapabilities` calls
   * @param address - The address of the user
   * @param caipNetwork - The CAIP network
   * @returns The balances of the user's tokens on the EIP155 network
   */
  async getEIP155Balances(address, caipNetwork) {
    var _a, _b;
    try {
      const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);
      const walletCapabilities = await ConnectionController.getCapabilities(address);
      if (!((_b = (_a = walletCapabilities == null ? void 0 : walletCapabilities[chainIdHex]) == null ? void 0 : _a["assetDiscovery"]) == null ? void 0 : _b.supported)) {
        return null;
      }
      const walletGetAssetsResponse = await ConnectionController.walletGetAssets({
        account: address,
        chainFilter: [chainIdHex]
      });
      if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {
        return null;
      }
      const assets = walletGetAssetsResponse[chainIdHex] || [];
      const filteredAssets = assets.map((asset) => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));
      StorageUtil.updateBalanceCache({
        caipAddress: `${caipNetwork.caipNetworkId}:${address}`,
        balance: { balances: filteredAssets },
        timestamp: Date.now()
      });
      return filteredAssets;
    } catch (error) {
      return null;
    }
  },
  /**
   * The 1Inch API includes many low-quality tokens in the balance response,
   * which appear inconsistently. This filter prevents them from being displayed.
   */
  filterLowQualityTokens(balances) {
    return balances.filter((balance) => balance.quantity.decimals !== "0");
  },
  async fetchERC20Balance({ caipAddress, assetAddress, caipNetwork }) {
    const publicClient = await ViemUtil.createViemPublicClient(caipNetwork);
    const { address } = ParseUtil.parseCaipAddress(caipAddress);
    const [{ result: name }, { result: symbol }, { result: balance }, { result: decimals }] = await publicClient.multicall({
      contracts: [
        {
          address: assetAddress,
          functionName: "name",
          args: [],
          abi: erc20Abi
        },
        {
          address: assetAddress,
          functionName: "symbol",
          args: [],
          abi: erc20Abi
        },
        {
          address: assetAddress,
          functionName: "balanceOf",
          args: [address],
          abi: erc20Abi
        },
        {
          address: assetAddress,
          functionName: "decimals",
          args: [],
          abi: erc20Abi
        }
      ]
    });
    return {
      name,
      symbol,
      decimals,
      balance: balance && decimals ? formatUnits(balance, decimals) : "0"
    };
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var state18 = proxy({
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map()
});
var controller11 = {
  state: state18,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state18, ref(newState));
  },
  subscribe(callback) {
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        return callback(accountState2);
      }
      return void 0;
    });
  },
  subscribeKey(property, callback, chain) {
    let prev = void 0;
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        const nextValue = accountState2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    }, chain);
  },
  setStatus(status, chain) {
    ChainController.setAccountProp("status", status, chain);
  },
  getCaipAddress(chain) {
    var _a, _b;
    if (!chain) {
      return void 0;
    }
    return (_b = (_a = ChainController.state.chains.get(chain)) == null ? void 0 : _a.accountState) == null ? void 0 : _b.caipAddress;
  },
  setCaipAddress(caipAddress, chain) {
    const newAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (chain === ChainController.state.activeChain) {
      ChainController.state.activeCaipAddress = caipAddress;
    }
    ChainController.setAccountProp("caipAddress", caipAddress, chain);
    ChainController.setAccountProp("address", newAddress, chain);
  },
  setBalance(balance, balanceSymbol, chain) {
    ChainController.setAccountProp("balance", balance, chain);
    ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
  },
  setProfileName(profileName, chain) {
    ChainController.setAccountProp("profileName", profileName, chain);
  },
  setProfileImage(profileImage, chain) {
    ChainController.setAccountProp("profileImage", profileImage, chain);
  },
  setUser(user, chain) {
    ChainController.setAccountProp("user", user, chain);
  },
  setAddressExplorerUrl(explorerUrl, chain) {
    ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain);
  },
  setSmartAccountDeployed(isDeployed, chain) {
    ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
  },
  setCurrentTab(currentTab) {
    ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
  },
  setTokenBalance(tokenBalance, chain) {
    if (tokenBalance) {
      ChainController.setAccountProp("tokenBalance", tokenBalance, chain);
    }
  },
  setShouldUpdateToAddress(address, chain) {
    ChainController.setAccountProp("shouldUpdateToAddress", address, chain);
  },
  addAddressLabel(address, label, chain) {
    var _a, _b;
    if (!chain) {
      return;
    }
    const map = ((_b = (_a = ChainController.state.chains.get(chain)) == null ? void 0 : _a.accountState) == null ? void 0 : _b.addressLabels) || /* @__PURE__ */ new Map();
    map.set(address, label);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  removeAddressLabel(address, chain) {
    var _a, _b;
    if (!chain) {
      return;
    }
    const map = ((_b = (_a = ChainController.state.chains.get(chain)) == null ? void 0 : _a.accountState) == null ? void 0 : _b.addressLabels) || /* @__PURE__ */ new Map();
    map.delete(address);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  setConnectedWalletInfo(connectedWalletInfo, chain) {
    ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain, false);
  },
  setPreferredAccountType(preferredAccountType, chain) {
    ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
  },
  setSocialProvider(socialProvider, chain) {
    if (socialProvider) {
      ChainController.setAccountProp("socialProvider", socialProvider, chain);
    }
  },
  setSocialWindow(socialWindow, chain) {
    ChainController.setAccountProp("socialWindow", socialWindow ? ref(socialWindow) : void 0, chain);
  },
  setFarcasterUrl(farcasterUrl, chain) {
    ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain);
  },
  async fetchTokenBalance(onError) {
    var _a, _b;
    state18.balanceLoading = true;
    const chainId = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId;
    const chain = (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.chainNamespace;
    const caipAddress = ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state18.lastRetry && !CoreHelperUtil.isAllowedRetry(state18.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
      state18.balanceLoading = false;
      return [];
    }
    try {
      if (address && chainId && chain) {
        const balance = await BalanceUtil.getMyTokensWithBalance();
        AccountController.setTokenBalance(balance, chain);
        state18.lastRetry = void 0;
        state18.balanceLoading = false;
        return balance;
      }
    } catch (error) {
      state18.lastRetry = Date.now();
      onError == null ? void 0 : onError(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state18.balanceLoading = false;
    }
    return [];
  },
  resetAccount(chain) {
    ChainController.resetAccount(chain);
  }
};
var AccountController = withErrorBoundary(controller11);

export {
  subscribeKey,
  ONRAMP_PROVIDERS,
  MELD_PUBLIC_KEY,
  ConstantsUtil2 as ConstantsUtil,
  StorageUtil,
  CoreHelperUtil,
  OptionsController,
  withErrorBoundary,
  SECURE_SITE_SDK,
  DEFAULT_LOG_LEVEL,
  SECURE_SITE_SDK_VERSION,
  W3mFrameConstants,
  W3mFrameRpcConstants,
  AssetController,
  AssetUtil,
  EventsController,
  ApiController,
  RouterController,
  ThemeController,
  ConnectorController,
  getActiveNetworkTokenAddress,
  getPreferredAccountType,
  getActiveCaipNetwork,
  ConnectionControllerUtil,
  SnackController,
  TransactionsController,
  ConnectionController,
  PublicStateController,
  SwapApiUtil,
  SendController,
  ChainController,
  BlockchainApiController,
  BalanceUtil,
  AccountController,
  NetworkUtil2 as NetworkUtil,
  ModalController
};
//# sourceMappingURL=chunk-QSUPKH3W.js.map
