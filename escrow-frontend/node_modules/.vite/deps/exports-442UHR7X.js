import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import "./chunk-N7JJBOYX.js";
import "./chunk-YEELUT3G.js";
import "./chunk-UVVCXIFK.js";
import "./chunk-KRO2WDQG.js";
import "./chunk-VKP36QUD.js";
import "./chunk-XHWFNSUA.js";
import "./chunk-JOSXZXMK.js";
import "./chunk-AI5AF6RN.js";
import "./chunk-L7BTMMBA.js";
import "./chunk-TM25KXGW.js";
import "./chunk-3WVCBTEI.js";
import "./chunk-7XOOFSZI.js";
import "./chunk-RGATGYAP.js";
import "./chunk-JE4364BU.js";
import {
  ifDefined
} from "./chunk-WM6KVWRK.js";
import "./chunk-DJVV3QEB.js";
import {
  state
} from "./chunk-4DQU66N6.js";
import {
  ProviderController,
  customElement
} from "./chunk-J7DBC6NA.js";
import {
  AccountController,
  AssetUtil,
  ChainController,
  ConnectionController,
  ConnectorController,
  CoreHelperUtil,
  EventsController,
  ModalController,
  OptionsController,
  RouterController,
  SnackController,
  ThemeController,
  subscribeKey
} from "./chunk-QSUPKH3W.js";
import "./chunk-PAEEZISA.js";
import "./chunk-OT4V75LP.js";
import {
  ConstantsUtil,
  ContractUtil,
  ParseUtil
} from "./chunk-LMWIBVXG.js";
import "./chunk-GRODQCUD.js";
import {
  LitElement,
  css,
  html
} from "./chunk-S23HMWR6.js";
import "./chunk-52PEDUJZ.js";
import {
  proxy,
  subscribe
} from "./chunk-RYD2VC23.js";
import "./chunk-N3ZYDEEA.js";
import "./chunk-YXHVIMER.js";
import "./chunk-XIZINAM5.js";
import "./chunk-IKQX5PK4.js";
import "./chunk-XY3TID46.js";
import "./chunk-4C5MNTRB.js";
import "./chunk-HY7BOZCL.js";
import "./chunk-GL4D7OOV.js";
import "./chunk-CDS7OQG7.js";
import "./chunk-T6M7DZNI.js";
import "./chunk-UM5MDUXH.js";
import "./chunk-53Y4ULFG.js";
import "./chunk-HIGI5P2L.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IJ3OGCUL.js";

// node_modules/@reown/appkit-pay/dist/esm/exports/index.js
var import_dist37 = __toESM(require_dist());
var import_dist38 = __toESM(require_dist2());
var import_dist39 = __toESM(require_dist3());

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-view/index.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-pay/dist/esm/src/controllers/PayController.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-pay/dist/esm/src/types/errors.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var AppKitPayErrorCodes = {
  INVALID_PAYMENT_CONFIG: "INVALID_PAYMENT_CONFIG",
  INVALID_RECIPIENT: "INVALID_RECIPIENT",
  INVALID_ASSET: "INVALID_ASSET",
  INVALID_AMOUNT: "INVALID_AMOUNT",
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  UNABLE_TO_INITIATE_PAYMENT: "UNABLE_TO_INITIATE_PAYMENT",
  INVALID_CHAIN_NAMESPACE: "INVALID_CHAIN_NAMESPACE",
  GENERIC_PAYMENT_ERROR: "GENERIC_PAYMENT_ERROR",
  UNABLE_TO_GET_EXCHANGES: "UNABLE_TO_GET_EXCHANGES",
  ASSET_NOT_SUPPORTED: "ASSET_NOT_SUPPORTED",
  UNABLE_TO_GET_PAY_URL: "UNABLE_TO_GET_PAY_URL",
  UNABLE_TO_GET_BUY_STATUS: "UNABLE_TO_GET_BUY_STATUS"
};
var AppKitPayErrorMessages = {
  [AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG]: "Invalid payment configuration",
  [AppKitPayErrorCodes.INVALID_RECIPIENT]: "Invalid recipient address",
  [AppKitPayErrorCodes.INVALID_ASSET]: "Invalid asset specified",
  [AppKitPayErrorCodes.INVALID_AMOUNT]: "Invalid payment amount",
  [AppKitPayErrorCodes.UNKNOWN_ERROR]: "Unknown payment error occurred",
  [AppKitPayErrorCodes.UNABLE_TO_INITIATE_PAYMENT]: "Unable to initiate payment",
  [AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE]: "Invalid chain namespace",
  [AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR]: "Unable to process payment",
  [AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES]: "Unable to get exchanges",
  [AppKitPayErrorCodes.ASSET_NOT_SUPPORTED]: "Asset not supported by the selected exchange",
  [AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL]: "Unable to get payment URL",
  [AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS]: "Unable to get buy status"
};
var AppKitPayError = class _AppKitPayError extends Error {
  get message() {
    return AppKitPayErrorMessages[this.code];
  }
  constructor(code, details) {
    super(AppKitPayErrorMessages[code]);
    this.name = "AppKitPayError";
    this.code = code;
    this.details = details;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _AppKitPayError);
    }
  }
};

// node_modules/@reown/appkit-pay/dist/esm/src/utils/ApiUtil.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-pay/dist/esm/src/utils/ConstantsUtil.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var API_URL = "https://rpc.walletconnect.org/v1/json-rpc";

// node_modules/@reown/appkit-pay/dist/esm/src/utils/ApiUtil.js
var JsonRpcError = class extends Error {
};
function getApiUrl() {
  const projectId = OptionsController.getSnapshot().projectId;
  return `${API_URL}?projectId=${projectId}`;
}
async function sendRequest(method, params) {
  const url = getApiUrl();
  const { sdkType: st, sdkVersion: sv, projectId } = OptionsController.getSnapshot();
  const requestBody = {
    jsonrpc: "2.0",
    id: 1,
    method,
    params: {
      ...params || {},
      st,
      sv,
      projectId
    }
  };
  const response = await fetch(url, {
    method: "POST",
    body: JSON.stringify(requestBody),
    headers: { "Content-Type": "application/json" }
  });
  const json = await response.json();
  if (json.error) {
    throw new JsonRpcError(json.error.message);
  }
  return json;
}
async function getExchanges(params) {
  const response = await sendRequest("reown_getExchanges", params);
  return response.result;
}
async function getPayUrl(params) {
  const response = await sendRequest("reown_getExchangePayUrl", params);
  return response.result;
}
async function getBuyStatus(params) {
  const response = await sendRequest("reown_getExchangeBuyStatus", params);
  return response.result;
}

// node_modules/@reown/appkit-pay/dist/esm/src/utils/AssetUtil.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var SUPPORT_PAY_WITH_WALLET_CHAIN_NAMESPACES = ["eip155", "solana"];
var CHAIN_ASSET_INFO_MAP = {
  eip155: {
    native: { assetNamespace: "slip44", assetReference: "60" },
    defaultTokenNamespace: "erc20"
  },
  solana: {
    native: { assetNamespace: "slip44", assetReference: "501" },
    defaultTokenNamespace: "token"
  }
};
function formatCaip19Asset(caipNetworkId, asset) {
  const { chainNamespace, chainId } = ParseUtil.parseCaipNetworkId(caipNetworkId);
  const chainInfo = CHAIN_ASSET_INFO_MAP[chainNamespace];
  if (!chainInfo) {
    throw new Error(`Unsupported chain namespace for CAIP-19 formatting: ${chainNamespace}`);
  }
  let assetNamespace = chainInfo.native.assetNamespace;
  let assetReference = chainInfo.native.assetReference;
  if (asset !== "native") {
    assetNamespace = chainInfo.defaultTokenNamespace;
    assetReference = asset;
  }
  const networkPart = `${chainNamespace}:${chainId}`;
  return `${networkPart}/${assetNamespace}:${assetReference}`;
}
function isPayWithWalletSupported(networkId) {
  const { chainNamespace } = ParseUtil.parseCaipNetworkId(networkId);
  return SUPPORT_PAY_WITH_WALLET_CHAIN_NAMESPACES.includes(chainNamespace);
}

// node_modules/@reown/appkit-pay/dist/esm/src/utils/PaymentUtil.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
async function ensureCorrectNetwork(options) {
  const { paymentAssetNetwork, activeCaipNetwork, approvedCaipNetworkIds, requestedCaipNetworks } = options;
  const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
  const assetCaipNetwork = sortedNetworks.find((network) => network.caipNetworkId === paymentAssetNetwork);
  if (!assetCaipNetwork) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  if (assetCaipNetwork.caipNetworkId === activeCaipNetwork.caipNetworkId) {
    return;
  }
  const isSupportingAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", assetCaipNetwork.chainNamespace);
  const isSwitchAllowed = (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(assetCaipNetwork.caipNetworkId)) || isSupportingAllNetworks;
  if (!isSwitchAllowed) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  try {
    await ChainController.switchActiveNetwork(assetCaipNetwork);
  } catch (error) {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, error);
  }
}
async function processEvmNativePayment(paymentAsset, chainNamespace, params) {
  var _a;
  if (chainNamespace !== ConstantsUtil.CHAIN.EVM) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
  }
  if (!params.fromAddress) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, "fromAddress is required for native EVM payments.");
  }
  const amountValue = typeof params.amount === "string" ? parseFloat(params.amount) : params.amount;
  if (isNaN(amountValue)) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  const decimals = ((_a = paymentAsset.metadata) == null ? void 0 : _a.decimals) ?? 18;
  const amountBigInt = ConnectionController.parseUnits(amountValue.toString(), decimals);
  if (typeof amountBigInt !== "bigint") {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR);
  }
  const txResponse = await ConnectionController.sendTransaction({
    chainNamespace,
    to: params.recipient,
    address: params.fromAddress,
    value: amountBigInt,
    data: "0x"
  });
  return txResponse ?? void 0;
}
async function processEvmErc20Payment(paymentAsset, params) {
  if (!params.fromAddress) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, "fromAddress is required for ERC20 EVM payments.");
  }
  const tokenAddress = paymentAsset.asset;
  const recipientAddress = params.recipient;
  const decimals = Number(paymentAsset.metadata.decimals);
  const amountBigInt = ConnectionController.parseUnits(params.amount.toString(), decimals);
  if (amountBigInt === void 0) {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR);
  }
  const txResponse = await ConnectionController.writeContract({
    fromAddress: params.fromAddress,
    tokenAddress,
    args: [recipientAddress, amountBigInt],
    method: "transfer",
    abi: ContractUtil.getERC20Abi(tokenAddress),
    chainNamespace: ConstantsUtil.CHAIN.EVM
  });
  return txResponse ?? void 0;
}
async function processSolanaPayment(chainNamespace, params) {
  if (chainNamespace !== ConstantsUtil.CHAIN.SOLANA) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
  }
  if (!params.fromAddress) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, "fromAddress is required for Solana payments.");
  }
  const amountValue = typeof params.amount === "string" ? parseFloat(params.amount) : params.amount;
  if (isNaN(amountValue) || amountValue <= 0) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, "Invalid payment amount.");
  }
  try {
    const provider = ProviderController.getProvider(chainNamespace);
    if (!provider) {
      throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, "No Solana provider available.");
    }
    const txResponse = await ConnectionController.sendTransaction({
      chainNamespace: ConstantsUtil.CHAIN.SOLANA,
      to: params.recipient,
      value: amountValue,
      tokenMint: params.tokenMint
    });
    if (!txResponse) {
      throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, "Transaction failed.");
    }
    return txResponse;
  } catch (error) {
    if (error instanceof AppKitPayError) {
      throw error;
    }
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, `Solana payment failed: ${error}`);
  }
}

// node_modules/@reown/appkit-pay/dist/esm/src/controllers/PayController.js
var DEFAULT_PAGE = 0;
var DEFAULT_PAYMENT_ID = "unknown";
var state2 = proxy({
  paymentAsset: {
    network: "eip155:1",
    asset: "0x0",
    metadata: {
      name: "0x0",
      symbol: "0x0",
      decimals: 0
    }
  },
  recipient: "0x0",
  amount: 0,
  isConfigured: false,
  error: null,
  isPaymentInProgress: false,
  exchanges: [],
  isLoading: false,
  openInNewTab: true,
  redirectUrl: void 0,
  payWithExchange: void 0,
  currentPayment: void 0,
  analyticsSet: false,
  paymentId: void 0
});
var PayController = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  async handleOpenPay(options) {
    this.resetState();
    this.setPaymentConfig(options);
    this.subscribeEvents();
    this.initializeAnalytics();
    state2.isConfigured = true;
    EventsController.sendEvent({
      type: "track",
      event: "PAY_MODAL_OPEN",
      properties: {
        exchanges: state2.exchanges,
        configuration: {
          network: state2.paymentAsset.network,
          asset: state2.paymentAsset.asset,
          recipient: state2.recipient,
          amount: state2.amount
        }
      }
    });
    await ModalController.open({
      view: "Pay"
    });
  },
  resetState() {
    state2.paymentAsset = {
      network: "eip155:1",
      asset: "0x0",
      metadata: { name: "0x0", symbol: "0x0", decimals: 0 }
    };
    state2.recipient = "0x0";
    state2.amount = 0;
    state2.isConfigured = false;
    state2.error = null;
    state2.isPaymentInProgress = false;
    state2.isLoading = false;
    state2.currentPayment = void 0;
  },
  setPaymentConfig(config) {
    if (!config.paymentAsset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
    }
    try {
      state2.paymentAsset = config.paymentAsset;
      state2.recipient = config.recipient;
      state2.amount = config.amount;
      state2.openInNewTab = config.openInNewTab ?? true;
      state2.redirectUrl = config.redirectUrl;
      state2.payWithExchange = config.payWithExchange;
      state2.error = null;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, error.message);
    }
  },
  getPaymentAsset() {
    return state2.paymentAsset;
  },
  getExchanges() {
    return state2.exchanges;
  },
  async fetchExchanges() {
    try {
      state2.isLoading = true;
      const response = await getExchanges({
        page: DEFAULT_PAGE,
        asset: formatCaip19Asset(state2.paymentAsset.network, state2.paymentAsset.asset),
        amount: state2.amount.toString()
      });
      state2.exchanges = response.exchanges.slice(0, 2);
    } catch (error) {
      SnackController.showError(AppKitPayErrorMessages.UNABLE_TO_GET_EXCHANGES);
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES);
    } finally {
      state2.isLoading = false;
    }
  },
  async getAvailableExchanges(params) {
    var _a;
    try {
      const asset = (params == null ? void 0 : params.asset) && (params == null ? void 0 : params.network) ? formatCaip19Asset(params.network, params.asset) : void 0;
      const response = await getExchanges({
        page: (params == null ? void 0 : params.page) ?? DEFAULT_PAGE,
        asset,
        amount: (_a = params == null ? void 0 : params.amount) == null ? void 0 : _a.toString()
      });
      return response;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES);
    }
  },
  async getPayUrl(exchangeId, params, headless = false) {
    try {
      const numericAmount = Number(params.amount);
      const response = await getPayUrl({
        exchangeId,
        asset: formatCaip19Asset(params.network, params.asset),
        amount: numericAmount.toString(),
        recipient: `${params.network}:${params.recipient}`
      });
      EventsController.sendEvent({
        type: "track",
        event: "PAY_EXCHANGE_SELECTED",
        properties: {
          source: "pay",
          exchange: {
            id: exchangeId
          },
          configuration: {
            network: params.network,
            asset: params.asset,
            recipient: params.recipient,
            amount: numericAmount
          },
          currentPayment: {
            type: "exchange",
            exchangeId
          },
          headless
        }
      });
      if (headless) {
        this.initiatePayment();
        EventsController.sendEvent({
          type: "track",
          event: "PAY_INITIATED",
          properties: {
            source: "pay",
            paymentId: state2.paymentId || DEFAULT_PAYMENT_ID,
            configuration: {
              network: params.network,
              asset: params.asset,
              recipient: params.recipient,
              amount: numericAmount
            },
            currentPayment: {
              type: "exchange",
              exchangeId
            }
          }
        });
      }
      return response;
    } catch (error) {
      if (error instanceof Error && error.message.includes("is not supported")) {
        throw new AppKitPayError(AppKitPayErrorCodes.ASSET_NOT_SUPPORTED);
      }
      throw new Error(error.message);
    }
  },
  async openPayUrl(openParams, params, headless = false) {
    try {
      const payUrl = await this.getPayUrl(openParams.exchangeId, params, headless);
      if (!payUrl) {
        throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL);
      }
      const shouldOpenInNewTab = openParams.openInNewTab ?? true;
      const target = shouldOpenInNewTab ? "_blank" : "_self";
      CoreHelperUtil.openHref(payUrl.url, target);
      return payUrl;
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL);
    }
  },
  subscribeEvents() {
    if (state2.isConfigured) {
      return;
    }
    ConnectionController.subscribeKey("connections", (connections) => {
      if (connections.size > 0) {
        this.handlePayment();
      }
    });
    AccountController.subscribeKey("caipAddress", (caipAddress) => {
      const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
      if (caipAddress) {
        if (hasWcConnection) {
          setTimeout(() => {
            this.handlePayment();
          }, 100);
        } else {
          this.handlePayment();
        }
      }
    });
  },
  async handlePayment() {
    state2.currentPayment = {
      type: "wallet",
      status: "IN_PROGRESS"
    };
    const caipAddress = AccountController.state.caipAddress;
    if (!caipAddress) {
      return;
    }
    const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
    const chainNamespace = ChainController.state.activeChain;
    if (!address || !chainId || !chainNamespace) {
      return;
    }
    const provider = ProviderController.getProvider(chainNamespace);
    if (!provider) {
      return;
    }
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return;
    }
    if (state2.isPaymentInProgress) {
      return;
    }
    try {
      this.initiatePayment();
      const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
      const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
      await ensureCorrectNetwork({
        paymentAssetNetwork: state2.paymentAsset.network,
        activeCaipNetwork: caipNetwork,
        approvedCaipNetworkIds,
        requestedCaipNetworks
      });
      await ModalController.open({
        view: "PayLoading"
      });
      switch (chainNamespace) {
        case ConstantsUtil.CHAIN.EVM:
          if (state2.paymentAsset.asset === "native") {
            state2.currentPayment.result = await processEvmNativePayment(state2.paymentAsset, chainNamespace, {
              recipient: state2.recipient,
              amount: state2.amount,
              fromAddress: address
            });
          }
          if (state2.paymentAsset.asset.startsWith("0x")) {
            state2.currentPayment.result = await processEvmErc20Payment(state2.paymentAsset, {
              recipient: state2.recipient,
              amount: state2.amount,
              fromAddress: address
            });
          }
          state2.currentPayment.status = "SUCCESS";
          break;
        case ConstantsUtil.CHAIN.SOLANA:
          state2.currentPayment.result = await processSolanaPayment(chainNamespace, {
            recipient: state2.recipient,
            amount: state2.amount,
            fromAddress: address,
            tokenMint: state2.paymentAsset.asset === "native" ? void 0 : state2.paymentAsset.asset
          });
          state2.currentPayment.status = "SUCCESS";
          break;
        default:
          throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
      }
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      state2.currentPayment.status = "FAILED";
      SnackController.showError(state2.error);
    } finally {
      state2.isPaymentInProgress = false;
    }
  },
  getExchangeById(exchangeId) {
    return state2.exchanges.find((exchange) => exchange.id === exchangeId);
  },
  validatePayConfig(config) {
    const { paymentAsset, recipient, amount } = config;
    if (!paymentAsset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
    }
    if (!recipient) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_RECIPIENT);
    }
    if (!paymentAsset.asset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_ASSET);
    }
    if (amount === void 0 || amount === null || amount <= 0) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_AMOUNT);
    }
  },
  handlePayWithWallet() {
    const caipAddress = AccountController.state.caipAddress;
    if (!caipAddress) {
      RouterController.push("Connect");
      return;
    }
    const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
    const chainNamespace = ChainController.state.activeChain;
    if (!address || !chainId || !chainNamespace) {
      RouterController.push("Connect");
      return;
    }
    this.handlePayment();
  },
  async handlePayWithExchange(exchangeId) {
    try {
      state2.currentPayment = {
        type: "exchange",
        exchangeId
      };
      const { network, asset } = state2.paymentAsset;
      const payUrlParams = {
        network,
        asset,
        amount: state2.amount,
        recipient: state2.recipient
      };
      const payUrl = await this.getPayUrl(exchangeId, payUrlParams);
      if (!payUrl) {
        throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_INITIATE_PAYMENT);
      }
      state2.currentPayment.sessionId = payUrl.sessionId;
      state2.currentPayment.status = "IN_PROGRESS";
      state2.currentPayment.exchangeId = exchangeId;
      this.initiatePayment();
      return {
        url: payUrl.url,
        openInNewTab: state2.openInNewTab
      };
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      state2.isPaymentInProgress = false;
      SnackController.showError(state2.error);
      return null;
    }
  },
  async getBuyStatus(exchangeId, sessionId) {
    var _a, _b;
    try {
      const status = await getBuyStatus({ sessionId, exchangeId });
      if (status.status === "SUCCESS" || status.status === "FAILED") {
        EventsController.sendEvent({
          type: "track",
          event: status.status === "SUCCESS" ? "PAY_SUCCESS" : "PAY_ERROR",
          properties: {
            source: "pay",
            paymentId: state2.paymentId || DEFAULT_PAYMENT_ID,
            configuration: {
              network: state2.paymentAsset.network,
              asset: state2.paymentAsset.asset,
              recipient: state2.recipient,
              amount: state2.amount
            },
            currentPayment: {
              type: "exchange",
              exchangeId: (_a = state2.currentPayment) == null ? void 0 : _a.exchangeId,
              sessionId: (_b = state2.currentPayment) == null ? void 0 : _b.sessionId,
              result: status.txHash
            }
          }
        });
      }
      return status;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS);
    }
  },
  async updateBuyStatus(exchangeId, sessionId) {
    try {
      const status = await this.getBuyStatus(exchangeId, sessionId);
      if (state2.currentPayment) {
        state2.currentPayment.status = status.status;
        state2.currentPayment.result = status.txHash;
      }
      if (status.status === "SUCCESS" || status.status === "FAILED") {
        state2.isPaymentInProgress = false;
      }
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS);
    }
  },
  initiatePayment() {
    state2.isPaymentInProgress = true;
    state2.paymentId = crypto.randomUUID();
  },
  initializeAnalytics() {
    if (state2.analyticsSet) {
      return;
    }
    state2.analyticsSet = true;
    this.subscribeKey("isPaymentInProgress", (_) => {
      var _a;
      if (((_a = state2.currentPayment) == null ? void 0 : _a.status) && state2.currentPayment.status !== "UNKNOWN") {
        const eventType = {
          IN_PROGRESS: "PAY_INITIATED",
          SUCCESS: "PAY_SUCCESS",
          FAILED: "PAY_ERROR"
        }[state2.currentPayment.status];
        EventsController.sendEvent({
          type: "track",
          event: eventType,
          properties: {
            source: "pay",
            paymentId: state2.paymentId || DEFAULT_PAYMENT_ID,
            configuration: {
              network: state2.paymentAsset.network,
              asset: state2.paymentAsset.asset,
              recipient: state2.recipient,
              amount: state2.amount
            },
            currentPayment: {
              type: state2.currentPayment.type,
              exchangeId: state2.currentPayment.exchangeId,
              sessionId: state2.currentPayment.sessionId,
              result: state2.currentPayment.result
            }
          }
        });
      }
    });
  }
};

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-view/styles.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var styles_default = css`
  wui-separator {
    margin: var(--apkt-spacing-3) calc(var(--apkt-spacing-3) * -1) var(--apkt-spacing-2)
      calc(var(--apkt-spacing-3) * -1);
    width: calc(100% + var(--apkt-spacing-3) * 2);
  }

  .token-display {
    padding: var(--apkt-spacing-3) var(--apkt-spacing-3);
    border-radius: var(--apkt-borderRadius-5);
    background-color: var(--apkt-tokens-theme-backgroundPrimary);
    margin-top: var(--apkt-spacing-3);
    margin-bottom: var(--apkt-spacing-3);
  }

  .token-display wui-text {
    text-transform: none;
  }

  wui-loading-spinner {
    padding: var(--apkt-spacing-2);
  }
`;

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-view/index.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var W3mPayView = class W3mPayView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.amount = "";
    this.tokenSymbol = "";
    this.networkName = "";
    this.exchanges = PayController.state.exchanges;
    this.isLoading = PayController.state.isLoading;
    this.loadingExchangeId = null;
    this.connectedWalletInfo = AccountController.state.connectedWalletInfo;
    this.initializePaymentDetails();
    this.unsubscribe.push(PayController.subscribeKey("exchanges", (val) => this.exchanges = val));
    this.unsubscribe.push(PayController.subscribeKey("isLoading", (val) => this.isLoading = val));
    this.unsubscribe.push(AccountController.subscribe((newState) => this.connectedWalletInfo = newState.connectedWalletInfo));
    PayController.fetchExchanges();
  }
  get isWalletConnected() {
    return AccountController.state.status === "connected";
  }
  render() {
    return html`
      <wui-flex flexDirection="column">
        <wui-flex flexDirection="column" .padding=${["0", "4", "4", "4"]} gap="3">
          ${this.renderPaymentHeader()}

          <wui-flex flexDirection="column" gap="3">
            ${this.renderPayWithWallet()} ${this.renderExchangeOptions()}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  initializePaymentDetails() {
    const paymentAsset = PayController.getPaymentAsset();
    this.networkName = paymentAsset.network;
    this.tokenSymbol = paymentAsset.metadata.symbol;
    this.amount = PayController.state.amount.toString();
  }
  renderPayWithWallet() {
    if (!isPayWithWalletSupported(this.networkName)) {
      return html``;
    }
    return html`<wui-flex flexDirection="column" gap="3">
        ${this.isWalletConnected ? this.renderConnectedView() : this.renderDisconnectedView()}
      </wui-flex>
      <wui-separator text="or"></wui-separator>`;
  }
  renderPaymentHeader() {
    let displayNetworkName = this.networkName;
    if (this.networkName) {
      const allNetworks = ChainController.getAllRequestedCaipNetworks();
      const targetNetwork = allNetworks.find((net) => net.caipNetworkId === this.networkName);
      if (targetNetwork) {
        displayNetworkName = targetNetwork["name"];
      }
    }
    return html`
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex alignItems="center" gap="2">
          <wui-text variant="h1-regular" color="primary">${this.amount || "0.0000"}</wui-text>
          <wui-flex class="token-display" alignItems="center" gap="1">
            <wui-text variant="md-medium" color="primary">
              ${this.tokenSymbol || "Unknown Asset"}
            </wui-text>
            ${displayNetworkName ? html`
                  <wui-text variant="sm-medium" color="secondary">
                    on ${displayNetworkName}
                  </wui-text>
                ` : ""}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  renderConnectedView() {
    var _a, _b;
    const walletName = ((_a = this.connectedWalletInfo) == null ? void 0 : _a.name) || "connected wallet";
    return html`
      <wui-list-item
        @click=${this.onWalletPayment}
        ?chevron=${true}
        ?fullSize=${true}
        ?rounded=${true}
        data-testid="wallet-payment-option"
        imageSrc=${ifDefined((_b = this.connectedWalletInfo) == null ? void 0 : _b.icon)}
      >
        <wui-text variant="lg-regular" color="primary">Pay with ${walletName}</wui-text>
      </wui-list-item>

      <wui-list-item
        icon="power"
        ?rounded=${true}
        iconColor="error"
        @click=${this.onDisconnect}
        data-testid="disconnect-button"
        ?chevron=${false}
      >
        <wui-text variant="lg-regular" color="secondary">Disconnect</wui-text>
      </wui-list-item>
    `;
  }
  renderDisconnectedView() {
    return html`<wui-list-item
      variant="icon"
      iconVariant="overlay"
      icon="wallet"
      ?rounded=${true}
      @click=${this.onWalletPayment}
      ?chevron=${true}
      data-testid="wallet-payment-option"
    >
      <wui-text variant="lg-regular" color="primary">Pay from wallet</wui-text>
    </wui-list-item>`;
  }
  renderExchangeOptions() {
    if (this.isLoading) {
      return html`<wui-flex justifyContent="center" alignItems="center">
        <wui-spinner size="md"></wui-spinner>
      </wui-flex>`;
    }
    if (this.exchanges.length === 0) {
      return html`<wui-flex justifyContent="center" alignItems="center">
        <wui-text variant="md-medium" color="primary">No exchanges available</wui-text>
      </wui-flex>`;
    }
    return this.exchanges.map((exchange) => html`
        <wui-list-item
          @click=${() => this.onExchangePayment(exchange.id)}
          data-testid="exchange-option-${exchange.id}"
          ?chevron=${true}
          ?disabled=${this.loadingExchangeId !== null}
          ?loading=${this.loadingExchangeId === exchange.id}
          imageSrc=${ifDefined(exchange.imageUrl)}
        >
          <wui-flex alignItems="center" gap="3">
            <wui-text flexGrow="1" variant="md-medium" color="primary"
              >Pay with ${exchange.name} <wui-spinner size="sm" color="secondary"></wui-spinner
            ></wui-text>
          </wui-flex>
        </wui-list-item>
      `);
  }
  onWalletPayment() {
    PayController.handlePayWithWallet();
  }
  async onExchangePayment(exchangeId) {
    try {
      this.loadingExchangeId = exchangeId;
      const result = await PayController.handlePayWithExchange(exchangeId);
      if (result) {
        await ModalController.open({
          view: "PayLoading"
        });
        CoreHelperUtil.openHref(result.url, result.openInNewTab ? "_blank" : "_self");
      }
    } catch (error) {
      console.error("Failed to pay with exchange", error);
      SnackController.showError("Failed to pay with exchange");
    } finally {
      this.loadingExchangeId = null;
    }
  }
  async onDisconnect(e) {
    e.stopPropagation();
    try {
      await ConnectionController.disconnect();
    } catch {
      console.error("Failed to disconnect");
      SnackController.showError("Failed to disconnect");
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
};
W3mPayView.styles = styles_default;
__decorate([
  state()
], W3mPayView.prototype, "amount", void 0);
__decorate([
  state()
], W3mPayView.prototype, "tokenSymbol", void 0);
__decorate([
  state()
], W3mPayView.prototype, "networkName", void 0);
__decorate([
  state()
], W3mPayView.prototype, "exchanges", void 0);
__decorate([
  state()
], W3mPayView.prototype, "isLoading", void 0);
__decorate([
  state()
], W3mPayView.prototype, "loadingExchangeId", void 0);
__decorate([
  state()
], W3mPayView.prototype, "connectedWalletInfo", void 0);
W3mPayView = __decorate([
  customElement("w3m-pay-view")
], W3mPayView);

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-loading-view/index.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-loading-view/styles.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
var styles_default2 = css`
  :host {
    display: block;
    height: 100%;
    width: 100%;
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }
`;

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-loading-view/index.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EXCHANGE_STATUS_CHECK_INTERVAL = 4e3;
var W3mPayLoadingView = class W3mPayLoadingView2 extends LitElement {
  constructor() {
    super();
    this.loadingMessage = "";
    this.subMessage = "";
    this.paymentState = "in-progress";
    this.paymentState = PayController.state.isPaymentInProgress ? "in-progress" : "completed";
    this.updateMessages();
    this.setupSubscription();
    this.setupExchangeSubscription();
  }
  disconnectedCallback() {
    clearInterval(this.exchangeSubscription);
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["7", "5", "5", "5"]}
        gap="9"
      >
        <wui-flex justifyContent="center" alignItems="center"> ${this.getStateIcon()} </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="2">
          <wui-text align="center" variant="lg-medium" color="primary">
            ${this.loadingMessage}
          </wui-text>
          <wui-text align="center" variant="lg-regular" color="secondary">
            ${this.subMessage}
          </wui-text>
        </wui-flex>
      </wui-flex>
    `;
  }
  updateMessages() {
    var _a;
    switch (this.paymentState) {
      case "completed":
        this.loadingMessage = "Payment completed";
        this.subMessage = "Your transaction has been successfully processed";
        break;
      case "error":
        this.loadingMessage = "Payment failed";
        this.subMessage = "There was an error processing your transaction";
        break;
      case "in-progress":
      default:
        if (((_a = PayController.state.currentPayment) == null ? void 0 : _a.type) === "exchange") {
          this.loadingMessage = "Payment initiated";
          this.subMessage = `Please complete the payment on the exchange`;
        } else {
          this.loadingMessage = "Awaiting payment confirmation";
          this.subMessage = "Please confirm the payment transaction in your wallet";
        }
        break;
    }
  }
  getStateIcon() {
    switch (this.paymentState) {
      case "completed":
        return this.successTemplate();
      case "error":
        return this.errorTemplate();
      case "in-progress":
      default:
        return this.loaderTemplate();
    }
  }
  setupExchangeSubscription() {
    var _a;
    if (((_a = PayController.state.currentPayment) == null ? void 0 : _a.type) !== "exchange") {
      return;
    }
    this.exchangeSubscription = setInterval(async () => {
      var _a2, _b, _c;
      const exchangeId = (_a2 = PayController.state.currentPayment) == null ? void 0 : _a2.exchangeId;
      const sessionId = (_b = PayController.state.currentPayment) == null ? void 0 : _b.sessionId;
      if (exchangeId && sessionId) {
        await PayController.updateBuyStatus(exchangeId, sessionId);
        if (((_c = PayController.state.currentPayment) == null ? void 0 : _c.status) === "SUCCESS") {
          clearInterval(this.exchangeSubscription);
        }
      }
    }, EXCHANGE_STATUS_CHECK_INTERVAL);
  }
  setupSubscription() {
    PayController.subscribeKey("isPaymentInProgress", (inProgress) => {
      var _a;
      if (!inProgress && this.paymentState === "in-progress") {
        if (PayController.state.error || !((_a = PayController.state.currentPayment) == null ? void 0 : _a.result)) {
          this.paymentState = "error";
        } else {
          this.paymentState = "completed";
        }
        this.updateMessages();
        setTimeout(() => {
          if (ConnectionController.state.status === "disconnected") {
            return;
          }
          ModalController.close();
        }, 3e3);
      }
    });
    PayController.subscribeKey("error", (error) => {
      if (error && this.paymentState === "in-progress") {
        this.paymentState = "error";
        this.updateMessages();
      }
    });
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    const iconSrc = this.getPaymentIcon();
    return html`
      <wui-flex justifyContent="center" alignItems="center" style="position: relative;">
        ${iconSrc ? html`<wui-wallet-image size="lg" imageSrc=${iconSrc}></wui-wallet-image>` : null}
        <wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>
      </wui-flex>
    `;
  }
  getPaymentIcon() {
    var _a;
    const currentPayment = PayController.state.currentPayment;
    if (!currentPayment) {
      return void 0;
    }
    if (currentPayment.type === "exchange") {
      const exchangeId = currentPayment.exchangeId;
      if (exchangeId) {
        const exchange = PayController.getExchangeById(exchangeId);
        return exchange == null ? void 0 : exchange.imageUrl;
      }
    }
    if (currentPayment.type === "wallet") {
      const walletIcon = (_a = AccountController.state.connectedWalletInfo) == null ? void 0 : _a.icon;
      if (walletIcon) {
        return walletIcon;
      }
      const chainNamespace = ChainController.state.activeChain;
      if (!chainNamespace) {
        return void 0;
      }
      const connectorId = ConnectorController.getConnectorId(chainNamespace);
      if (!connectorId) {
        return void 0;
      }
      const connector = ConnectorController.getConnectorById(connectorId);
      if (!connector) {
        return void 0;
      }
      return AssetUtil.getConnectorImage(connector);
    }
    return void 0;
  }
  successTemplate() {
    return html`<wui-icon size="xl" color="success" name="checkmark"></wui-icon>`;
  }
  errorTemplate() {
    return html`<wui-icon size="xl" color="error" name="close"></wui-icon>`;
  }
};
W3mPayLoadingView.styles = styles_default2;
__decorate2([
  state()
], W3mPayLoadingView.prototype, "loadingMessage", void 0);
__decorate2([
  state()
], W3mPayLoadingView.prototype, "subMessage", void 0);
__decorate2([
  state()
], W3mPayLoadingView.prototype, "paymentState", void 0);
W3mPayLoadingView = __decorate2([
  customElement("w3m-pay-loading-view")
], W3mPayLoadingView);

// node_modules/@reown/appkit-pay/dist/esm/src/client.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var PAYMENT_TIMEOUT_MS = 3e5;
async function openPay(options) {
  return PayController.handleOpenPay(options);
}
async function pay(options, timeoutMs = PAYMENT_TIMEOUT_MS) {
  if (timeoutMs <= 0) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, "Timeout must be greater than 0");
  }
  try {
    await openPay(options);
  } catch (error) {
    if (error instanceof AppKitPayError) {
      throw error;
    }
    throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_INITIATE_PAYMENT, error.message);
  }
  return new Promise((resolve, reject) => {
    let isSettled = false;
    const timeoutId = setTimeout(() => {
      if (isSettled) {
        return;
      }
      isSettled = true;
      cleanup();
      reject(new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, "Payment timeout"));
    }, timeoutMs);
    function checkAndResolve() {
      if (isSettled) {
        return;
      }
      const currentPayment = PayController.state.currentPayment;
      const error = PayController.state.error;
      const isInProgress = PayController.state.isPaymentInProgress;
      if ((currentPayment == null ? void 0 : currentPayment.status) === "SUCCESS") {
        isSettled = true;
        cleanup();
        clearTimeout(timeoutId);
        resolve({
          success: true,
          result: currentPayment.result
        });
        return;
      }
      if ((currentPayment == null ? void 0 : currentPayment.status) === "FAILED") {
        isSettled = true;
        cleanup();
        clearTimeout(timeoutId);
        resolve({
          success: false,
          error: error || "Payment failed"
        });
        return;
      }
      if (error && !isInProgress && !currentPayment) {
        isSettled = true;
        cleanup();
        clearTimeout(timeoutId);
        resolve({
          success: false,
          error
        });
      }
    }
    const unsubscribePayment = subscribeStateKey("currentPayment", checkAndResolve);
    const unsubscribeError = subscribeStateKey("error", checkAndResolve);
    const unsubscribeProgress = subscribeStateKey("isPaymentInProgress", checkAndResolve);
    const cleanup = createCleanupHandler([
      unsubscribePayment,
      unsubscribeError,
      unsubscribeProgress
    ]);
    checkAndResolve();
  });
}
function getExchanges2() {
  return PayController.getExchanges();
}
function getPayResult() {
  var _a;
  return (_a = PayController.state.currentPayment) == null ? void 0 : _a.result;
}
function getPayError() {
  return PayController.state.error;
}
function getIsPaymentInProgress() {
  return PayController.state.isPaymentInProgress;
}
function subscribeStateKey(key, callback) {
  return PayController.subscribeKey(key, callback);
}
function createCleanupHandler(unsubscribeFunctions) {
  return () => {
    unsubscribeFunctions.forEach((unsubscribe) => {
      try {
        unsubscribe();
      } catch {
      }
    });
  };
}

// node_modules/@reown/appkit-pay/dist/esm/src/types/assets.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var baseETH = {
  network: "eip155:8453",
  asset: "native",
  metadata: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  }
};
var baseUSDC = {
  network: "eip155:8453",
  asset: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var baseSepoliaETH = {
  network: "eip155:84532",
  asset: "native",
  metadata: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  }
};
var ethereumUSDC = {
  network: "eip155:1",
  asset: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var optimismUSDC = {
  network: "eip155:10",
  asset: "0x0b2c639c533813f4aa9d7837caf62653d097ff85",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var arbitrumUSDC = {
  network: "eip155:42161",
  asset: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var polygonUSDC = {
  network: "eip155:137",
  asset: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var solanaUSDC = {
  network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  asset: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var ethereumUSDT = {
  network: "eip155:1",
  asset: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  metadata: {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6
  }
};
var optimismUSDT = {
  network: "eip155:10",
  asset: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
  metadata: {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6
  }
};
var arbitrumUSDT = {
  network: "eip155:42161",
  asset: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
  metadata: {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6
  }
};
var polygonUSDT = {
  network: "eip155:137",
  asset: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
  metadata: {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6
  }
};
var solanaUSDT = {
  network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  asset: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
  metadata: {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6
  }
};
var solanaSOL = {
  network: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  asset: "native",
  metadata: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9
  }
};
export {
  W3mPayLoadingView,
  W3mPayView,
  arbitrumUSDC,
  arbitrumUSDT,
  baseETH,
  baseSepoliaETH,
  baseUSDC,
  ethereumUSDC,
  ethereumUSDT,
  getExchanges2 as getExchanges,
  getIsPaymentInProgress,
  getPayError,
  getPayResult,
  openPay,
  optimismUSDC,
  optimismUSDT,
  pay,
  polygonUSDC,
  polygonUSDT,
  solanaSOL,
  solanaUSDC,
  solanaUSDT
};
//# sourceMappingURL=exports-442UHR7X.js.map
