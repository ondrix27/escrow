import{V as Ze,X as Ce,Y as ke,Z as he,_ as Ot}from"./index-d3e05a27.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt=BigInt(0),jt=BigInt(1);function Bt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function nt(t){if(!Bt(t))throw new Error("Uint8Array expected")}function yt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function _t(t){const n=t.toString(16);return n.length&1?"0"+n:n}function we(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Qt:BigInt("0x"+t)}const ge=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",ze=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function bt(t){if(nt(t),ge)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=ze[t[e]];return n}const Q={_0:48,_9:57,A:65,F:70,a:97,f:102};function re(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q.A&&t<=Q.F)return t-(Q.A-10);if(t>=Q.a&&t<=Q.f)return t-(Q.a-10)}function qt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(ge)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const c=re(t.charCodeAt(i)),f=re(t.charCodeAt(i+1));if(c===void 0||f===void 0){const o=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+i)}r[s]=c*16+f}return r}function $(t){return we(bt(t))}function me(t){return nt(t),we(bt(Uint8Array.from(t).reverse()))}function ft(t,n){return qt(t.toString(16).padStart(n*2,"0"))}function ye(t,n){return ft(t,n).reverse()}function V(t,n,e){let r;if(typeof n=="string")try{r=qt(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(Bt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function D(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];nt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const i=t[r];e.set(i,s),s+=i.length}return e}function Jt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const zt=t=>typeof t=="bigint"&&Qt<=t;function Et(t,n,e){return zt(t)&&zt(n)&&zt(e)&&n<=t&&t<e}function ct(t,n,e,r){if(!Et(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Le(t){let n;for(n=0;t>Qt;t>>=jt,n+=1);return n}const Tt=t=>(jt<<BigInt(t))-jt,Lt=t=>new Uint8Array(t),oe=t=>Uint8Array.from(t);function Ve(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lt(t),s=Lt(t),i=0;const c=()=>{r.fill(1),s.fill(0),i=0},f=(...m)=>e(s,r,...m),o=(m=Lt(0))=>{s=f(oe([0]),m),r=f(),m.length!==0&&(s=f(oe([1]),m),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let m=0;const v=[];for(;m<n;){r=f();const p=r.slice();v.push(p),m+=r.length}return D(...v)};return(m,v)=>{c(),o(m);let p;for(;!(p=v(u()));)o();return c(),p}}const Pe={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||Bt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function St(t,n,e={}){const r=(s,i,c)=>{const f=Pe[i];if(typeof f!="function")throw new Error("invalid validator function");const o=t[s];if(!(c&&o===void 0)&&!f(o,t))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+o)};for(const[s,i]of Object.entries(n))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return t}function ie(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const i=t(e,...r);return n.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),H=BigInt(1),st=BigInt(2),Me=BigInt(3),be=BigInt(4),Ee=BigInt(5),pe=BigInt(8);function L(t,n){const e=t%n;return e>=K?e:n+e}function j(t,n,e){let r=t;for(;n-- >K;)r*=r,r%=e;return r}function Dt(t,n){if(t===K)throw new Error("invert: expected non-zero number");if(n<=K)throw new Error("invert: expected positive modulus, got "+n);let e=L(t,n),r=n,s=K,i=H;for(;e!==K;){const f=r/e,o=r%e,u=s-i*f;r=e,e=o,s=i,i=u}if(r!==H)throw new Error("invert: does not exist");return L(s,n)}function ve(t,n){const e=(t.ORDER+H)/be,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function He(t,n){const e=(t.ORDER-Ee)/pe,r=t.mul(n,st),s=t.pow(r,e),i=t.mul(n,s),c=t.mul(t.mul(i,st),s),f=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function Ye(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-H,e=0;for(;n%st===K;)n/=st,e++;let r=st;const s=Ft(t);for(;se(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return ve;let i=s.pow(r,n);const c=(n+H)/st;return function(o,u){if(o.is0(u))return u;if(se(o,u)!==1)throw new Error("Cannot find square root");let d=e,m=o.mul(o.ONE,i),v=o.pow(u,n),p=o.pow(u,c);for(;!o.eql(v,o.ONE);){if(o.is0(v))return o.ZERO;let N=1,g=o.sqr(v);for(;!o.eql(g,o.ONE);)if(N++,g=o.sqr(g),N===d)throw new Error("Cannot find square root");const C=H<<BigInt(d-N-1),_=o.pow(m,C);d=N,m=o.sqr(_),v=o.mul(v,m),p=o.mul(p,_)}return p}}function Ke(t){return t%be===Me?ve:t%pe===Ee?He:Ye(t)}const je=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=je.reduce((r,s)=>(r[s]="function",r),n);return St(t,e)}function De(t,n,e){if(e<K)throw new Error("invalid exponent, negatives unsupported");if(e===K)return t.ONE;if(e===H)return n;let r=t.ONE,s=n;for(;e>K;)e&H&&(r=t.mul(r,s)),s=t.sqr(s),e>>=H;return r}function Ut(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,o)=>t.is0(f)?c:(r[o]=c,t.mul(c,f)),t.ONE),i=t.inv(s);return n.reduceRight((c,f,o)=>t.is0(f)?c:(r[o]=t.mul(c,r[o]),t.mul(c,f)),i),r}function se(t,n){const e=(t.ORDER-H)/st,r=t.pow(n,e),s=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!i&&!c)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Be(t,n){n!==void 0&&Ze(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Ft(t,n,e=!1,r={}){if(t<=K)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:i}=Be(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:i,MASK:Tt(s),ZERO:K,ONE:H,create:o=>L(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return K<=o&&o<t},is0:o=>o===K,isOdd:o=>(o&H)===H,neg:o=>L(-o,t),eql:(o,u)=>o===u,sqr:o=>L(o*o,t),add:(o,u)=>L(o+u,t),sub:(o,u)=>L(o-u,t),mul:(o,u)=>L(o*u,t),pow:(o,u)=>De(f,o,u),div:(o,u)=>L(o*Dt(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>Dt(o,t),sqrt:r.sqrt||(o=>(c||(c=Ke(t)),c(f,o))),toBytes:o=>e?ye(o,i):ft(o,i),fromBytes:o=>{if(o.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+o.length);return e?me(o):$(o)},invertBatch:o=>Ut(f,o),cmov:(o,u,d)=>d?u:o});return Object.freeze(f)}function Se(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Ae(t){const n=Se(t);return n+Math.ceil(n/2)}function We(t,n,e=!1){const r=t.length,s=Se(n),i=Ae(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const c=e?me(t):$(t),f=L(c,n-H)+H;return e?ye(f,s):ft(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ce=BigInt(0),Wt=BigInt(1);function Vt(t,n){const e=n.negate();return t?e:n}function _e(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Pt(t,n){_e(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),s=2**t,i=Tt(t),c=BigInt(t);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:c}}function fe(t,n,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:c}=e;let f=Number(t&s),o=t>>c;f>r&&(f-=i,o+=Wt);const u=n*r,d=u+Math.abs(f)-1,m=f===0,v=f<0,p=n%2!==0;return{nextN:o,offset:d,isZero:m,isNeg:v,isNegF:p,offsetF:u}}function Ge(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function $e(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Mt=new WeakMap,Oe=new WeakMap;function Ht(t){return Oe.get(t)||1}function Xe(t,n){return{constTimeNegate:Vt,hasPrecomputes(e){return Ht(e)!==1},unsafeLadder(e,r,s=t.ZERO){let i=e;for(;r>ce;)r&Wt&&(s=s.add(i)),i=i.double(),r>>=Wt;return s},precomputeWindow(e,r){const{windows:s,windowSize:i}=Pt(r,n),c=[];let f=e,o=f;for(let u=0;u<s;u++){o=f,c.push(o);for(let d=1;d<i;d++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(e,r,s){let i=t.ZERO,c=t.BASE;const f=Pt(e,n);for(let o=0;o<f.windows;o++){const{nextN:u,offset:d,isZero:m,isNeg:v,isNegF:p,offsetF:N}=fe(s,o,f);s=u,m?c=c.add(Vt(p,r[N])):i=i.add(Vt(v,r[d]))}return{p:i,f:c}},wNAFUnsafe(e,r,s,i=t.ZERO){const c=Pt(e,n);for(let f=0;f<c.windows&&s!==ce;f++){const{nextN:o,offset:u,isZero:d,isNeg:m}=fe(s,f,c);if(s=o,!d){const v=r[u];i=i.add(m?v.negate():v)}}return i},getPrecomputes(e,r,s){let i=Mt.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&Mt.set(r,s(i))),i},wNAFCached(e,r,s){const i=Ht(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){const c=Ht(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,i)},setWindowSize(e,r){_e(r,n),Oe.set(e,r),Mt.delete(e)}}}function Qe(t,n,e,r){Ge(e,t),$e(r,n);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=Le(BigInt(s));let o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);const u=Tt(o),d=new Array(Number(u)+1).fill(c),m=Math.floor((n.BITS-1)/o)*o;let v=c;for(let p=m;p>=0;p-=o){d.fill(c);for(let g=0;g<i;g++){const C=r[g],_=Number(C>>BigInt(p)&u);d[_]=d[_].add(e[g])}let N=c;for(let g=d.length-1,C=c;g>0;g--)C=C.add(d[g]),N=N.add(C);if(v=v.add(N),p!==0)for(let g=0;g<o;g++)v=v.double()}return v}function qe(t){return xe(t.Fp),St(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Be(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ae(t){t.lowS!==void 0&&yt("lowS",t.lowS),t.prehash!==void 0&&yt("prehash",t.prehash)}function Je(t){const n=qe(t);St(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class Fe extends Error{constructor(n=""){super(n)}}const J={Err:Fe,_tlv:{encode:(t,n)=>{const{Err:e}=J;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=_t(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?_t(s.length/2|128):"";return _t(t)+i+s+n},decode(t,n){const{Err:e}=J;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],i=!!(s&128);let c=0;if(!i)c=s;else{const o=s&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)c=c<<8|d;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=J;if(t<G)throw new n("integer: negative integers are not allowed");let e=_t(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=J;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return $(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=J,s=V("signature",t),{v:i,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,i),{v:u,l:d}=r.decode(2,o);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=J,r=n.encode(2,e.encode(t.r)),s=n.encode(2,e.encode(t.s)),i=r+s;return n.encode(48,i)}};function Yt(t,n){return bt(ft(t,n))}const G=BigInt(0),k=BigInt(1),tt=BigInt(2),mt=BigInt(3),Gt=BigInt(4);function tn(t){const n=Je(t),{Fp:e}=n,r=Ft(n.n,n.nBitLength),s=n.toBytes||((y,a,w)=>{const b=a.toAffine();return D(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=n.fromBytes||(y=>{const a=y.subarray(1),w=e.fromBytes(a.subarray(0,e.BYTES)),b=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:w,y:b}});function c(y){const{a,b:w}=n,b=e.sqr(y),x=e.mul(b,y);return e.add(e.add(x,e.mul(y,a)),w)}function f(y,a){const w=e.sqr(a),b=c(y);return e.eql(w,b)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=e.mul(e.pow(n.a,mt),Gt),u=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,u)))throw new Error("bad curve params: a or b");function d(y){return Et(y,k,n.n)}function m(y){const{allowedPrivateKeyLengths:a,nByteLength:w,wrapPrivateKey:b,n:x}=n;if(a&&typeof y!="bigint"){if(Bt(y)&&(y=bt(y)),typeof y!="string"||!a.includes(y.length))throw new Error("invalid private key");y=y.padStart(w*2,"0")}let O;try{O=typeof y=="bigint"?y:$(V("private key",y,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof y)}return b&&(O=L(O,x)),ct("private key",O,k,x),O}function v(y){if(!(y instanceof g))throw new Error("ProjectivePoint expected")}const p=ie((y,a)=>{const{px:w,py:b,pz:x}=y;if(e.eql(x,e.ONE))return{x:w,y:b};const O=y.is0();a==null&&(a=O?e.ONE:e.inv(x));const U=e.mul(w,a),Z=e.mul(b,a),B=e.mul(x,a);if(O)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:U,y:Z}}),N=ie(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:a,y:w}=y.toAffine();if(!e.isValid(a)||!e.isValid(w))throw new Error("bad point: x or y not FE");if(!f(a,w))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(a,w,b){if(a==null||!e.isValid(a))throw new Error("x required");if(w==null||!e.isValid(w)||e.is0(w))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");this.px=a,this.py=w,this.pz=b,Object.freeze(this)}static fromAffine(a){const{x:w,y:b}=a||{};if(!a||!e.isValid(w)||!e.isValid(b))throw new Error("invalid affine point");if(a instanceof g)throw new Error("projective point not allowed");const x=O=>e.eql(O,e.ZERO);return x(w)&&x(b)?g.ZERO:new g(w,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const w=Ut(e,a.map(b=>b.pz));return a.map((b,x)=>b.toAffine(w[x])).map(g.fromAffine)}static fromHex(a){const w=g.fromAffine(i(V("pointHex",a)));return w.assertValidity(),w}static fromPrivateKey(a){return g.BASE.multiply(m(a))}static msm(a,w){return Qe(g,r,a,w)}_setWindowSize(a){T.setWindowSize(this,a)}assertValidity(){N(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){v(a);const{px:w,py:b,pz:x}=this,{px:O,py:U,pz:Z}=a,B=e.eql(e.mul(w,Z),e.mul(O,x)),R=e.eql(e.mul(b,Z),e.mul(U,x));return B&&R}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a,b:w}=n,b=e.mul(w,mt),{px:x,py:O,pz:U}=this;let Z=e.ZERO,B=e.ZERO,R=e.ZERO,S=e.mul(x,x),P=e.mul(O,O),h=e.mul(U,U),l=e.mul(x,O);return l=e.add(l,l),R=e.mul(x,U),R=e.add(R,R),Z=e.mul(a,R),B=e.mul(b,h),B=e.add(Z,B),Z=e.sub(P,B),B=e.add(P,B),B=e.mul(Z,B),Z=e.mul(l,Z),R=e.mul(b,R),h=e.mul(a,h),l=e.sub(S,h),l=e.mul(a,l),l=e.add(l,R),R=e.add(S,S),S=e.add(R,S),S=e.add(S,h),S=e.mul(S,l),B=e.add(B,S),h=e.mul(O,U),h=e.add(h,h),S=e.mul(h,l),Z=e.sub(Z,S),R=e.mul(h,P),R=e.add(R,R),R=e.add(R,R),new g(Z,B,R)}add(a){v(a);const{px:w,py:b,pz:x}=this,{px:O,py:U,pz:Z}=a;let B=e.ZERO,R=e.ZERO,S=e.ZERO;const P=n.a,h=e.mul(n.b,mt);let l=e.mul(w,O),E=e.mul(b,U),I=e.mul(x,Z),A=e.add(w,b),q=e.add(O,U);A=e.mul(A,q),q=e.add(l,E),A=e.sub(A,q),q=e.add(w,x);let z=e.add(O,Z);return q=e.mul(q,z),z=e.add(l,I),q=e.sub(q,z),z=e.add(b,x),B=e.add(U,Z),z=e.mul(z,B),B=e.add(E,I),z=e.sub(z,B),S=e.mul(P,q),B=e.mul(h,I),S=e.add(B,S),B=e.sub(E,S),S=e.add(E,S),R=e.mul(B,S),E=e.add(l,l),E=e.add(E,l),I=e.mul(P,I),q=e.mul(h,q),E=e.add(E,I),I=e.sub(l,I),I=e.mul(P,I),q=e.add(q,I),l=e.mul(E,q),R=e.add(R,l),l=e.mul(z,q),B=e.mul(A,B),B=e.sub(B,l),l=e.mul(A,E),S=e.mul(z,S),S=e.add(S,l),new g(B,R,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(g.ZERO)}wNAF(a){return T.wNAFCached(this,a,g.normalizeZ)}multiplyUnsafe(a){const{endo:w,n:b}=n;ct("scalar",a,G,b);const x=g.ZERO;if(a===G)return x;if(this.is0()||a===k)return this;if(!w||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,a,g.normalizeZ);let{k1neg:O,k1:U,k2neg:Z,k2:B}=w.splitScalar(a),R=x,S=x,P=this;for(;U>G||B>G;)U&k&&(R=R.add(P)),B&k&&(S=S.add(P)),P=P.double(),U>>=k,B>>=k;return O&&(R=R.negate()),Z&&(S=S.negate()),S=new g(e.mul(S.px,w.beta),S.py,S.pz),R.add(S)}multiply(a){const{endo:w,n:b}=n;ct("scalar",a,k,b);let x,O;if(w){const{k1neg:U,k1:Z,k2neg:B,k2:R}=w.splitScalar(a);let{p:S,f:P}=this.wNAF(Z),{p:h,f:l}=this.wNAF(R);S=T.constTimeNegate(U,S),h=T.constTimeNegate(B,h),h=new g(e.mul(h.px,w.beta),h.py,h.pz),x=S.add(h),O=P.add(l)}else{const{p:U,f:Z}=this.wNAF(a);x=U,O=Z}return g.normalizeZ([x,O])[0]}multiplyAndAddUnsafe(a,w,b){const x=g.BASE,O=(Z,B)=>B===G||B===k||!Z.equals(x)?Z.multiplyUnsafe(B):Z.multiply(B),U=O(this,w).add(O(a,b));return U.is0()?void 0:U}toAffine(a){return p(this,a)}isTorsionFree(){const{h:a,isTorsionFree:w}=n;if(a===k)return!0;if(w)return w(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:w}=n;return a===k?this:w?w(g,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return yt("isCompressed",a),this.assertValidity(),s(g,this,a)}toHex(a=!0){return yt("isCompressed",a),bt(this.toRawBytes(a))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const{endo:C,nBitLength:_}=n,T=Xe(g,C?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:m,weierstrassEquation:c,isWithinCurveOrder:d}}function en(t){const n=qe(t);return St(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function nn(t){const n=en(t),{Fp:e,n:r,nByteLength:s,nBitLength:i}=n,c=e.BYTES+1,f=2*e.BYTES+1;function o(h){return L(h,r)}function u(h){return Dt(h,r)}const{ProjectivePoint:d,normPrivateKeyToScalar:m,weierstrassEquation:v,isWithinCurveOrder:p}=tn({...n,toBytes(h,l,E){const I=l.toAffine(),A=e.toBytes(I.x),q=D;return yt("isCompressed",E),E?q(Uint8Array.from([l.hasEvenY()?2:3]),A):q(Uint8Array.from([4]),A,e.toBytes(I.y))},fromBytes(h){const l=h.length,E=h[0],I=h.subarray(1);if(l===c&&(E===2||E===3)){const A=$(I);if(!Et(A,k,e.ORDER))throw new Error("Point is not on curve");const q=v(A);let z;try{z=e.sqrt(q)}catch(W){const Y=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+Y)}const M=(z&k)===k;return(E&1)===1!==M&&(z=e.neg(z)),{x:A,y:z}}else if(l===f&&E===4){const A=e.fromBytes(I.subarray(0,e.BYTES)),q=e.fromBytes(I.subarray(e.BYTES,2*e.BYTES));return{x:A,y:q}}else{const A=c,q=f;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+q+", got "+l)}}});function N(h){const l=r>>k;return h>l}function g(h){return N(h)?o(-h):h}const C=(h,l,E)=>$(h.slice(l,E));class _{constructor(l,E,I){ct("r",l,k,r),ct("s",E,k,r),this.r=l,this.s=E,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(l){const E=s;return l=V("compactSignature",l,E*2),new _(C(l,0,E),C(l,E,2*E))}static fromDER(l){const{r:E,s:I}=J.toSig(V("DER",l));return new _(E,I)}assertValidity(){}addRecoveryBit(l){return new _(this.r,this.s,l)}recoverPublicKey(l){const{r:E,s:I,recovery:A}=this,q=x(V("msgHash",l));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const z=A===2||A===3?E+n.n:E;if(z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=A&1?"03":"02",X=d.fromHex(M+Yt(z,e.BYTES)),W=u(z),Y=o(-q*W),at=o(I*W),F=d.BASE.multiplyAndAddUnsafe(X,Y,at);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return qt(this.toDERHex())}toDERHex(){return J.hexFromSig(this)}toCompactRawBytes(){return qt(this.toCompactHex())}toCompactHex(){const l=s;return Yt(this.r,l)+Yt(this.s,l)}}const T={isValidPrivateKey(h){try{return m(h),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const h=Ae(n.n);return We(n.randomBytes(h),n.n)},precompute(h=8,l=d.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}};function y(h,l=!0){return d.fromPrivateKey(h).toRawBytes(l)}function a(h){if(typeof h=="bigint")return!1;if(h instanceof d)return!0;const E=V("key",h).length,I=e.BYTES,A=I+1,q=2*I+1;if(!(n.allowedPrivateKeyLengths||s===A))return E===A||E===q}function w(h,l,E=!0){if(a(h)===!0)throw new Error("first arg must be private key");if(a(l)===!1)throw new Error("second arg must be public key");return d.fromHex(l).multiply(m(h)).toRawBytes(E)}const b=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const l=$(h),E=h.length*8-i;return E>0?l>>BigInt(E):l},x=n.bits2int_modN||function(h){return o(b(h))},O=Tt(i);function U(h){return ct("num < 2^"+i,h,G,O),ft(h,s)}function Z(h,l,E=B){if(["recovered","canonical"].some(ot=>ot in E))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:A}=n;let{lowS:q,prehash:z,extraEntropy:M}=E;q==null&&(q=!0),h=V("msgHash",h),ae(E),z&&(h=V("prehashed msgHash",I(h)));const X=x(h),W=m(l),Y=[U(W),U(X)];if(M!=null&&M!==!1){const ot=M===!0?A(e.BYTES):M;Y.push(V("extraEntropy",ot))}const at=D(...Y),F=X;function Ct(ot){const ut=b(ot);if(!p(ut))return;const kt=u(ut),ht=d.BASE.multiply(ut).toAffine(),it=o(ht.x);if(it===G)return;const wt=o(kt*o(F+it*W));if(wt===G)return;let gt=(ht.x===it?0:2)|Number(ht.y&k),lt=wt;return q&&N(wt)&&(lt=g(wt),gt^=1),new _(it,lt,gt)}return{seed:at,k2sig:Ct}}const B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};function S(h,l,E=B){const{seed:I,k2sig:A}=Z(h,l,E),q=n;return Ve(q.hash.outputLen,q.nByteLength,q.hmac)(I,A)}d.BASE._setWindowSize(8);function P(h,l,E,I=R){var gt;const A=h;l=V("msgHash",l),E=V("publicKey",E);const{lowS:q,prehash:z,format:M}=I;if(ae(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const X=typeof A=="string"||Bt(A),W=!X&&!M&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!X&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Y,at;try{if(W&&(Y=new _(A.r,A.s)),X){try{M!=="compact"&&(Y=_.fromDER(A))}catch(lt){if(!(lt instanceof J.Err))throw lt}!Y&&M!=="der"&&(Y=_.fromCompact(A))}at=d.fromHex(E)}catch{return!1}if(!Y||q&&Y.hasHighS())return!1;z&&(l=n.hash(l));const{r:F,s:Ct}=Y,ot=x(l),ut=u(Ct),kt=o(ot*ut),ht=o(F*ut),it=(gt=d.BASE.multiplyAndAddUnsafe(at,kt,ht))==null?void 0:gt.toAffine();return it?o(it.x)===F:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:w,sign:S,verify:P,ProjectivePoint:d,Signature:_,utils:T}}function rn(t,n){const e=t.ORDER;let r=G;for(let N=e-k;N%tt===G;N/=tt)r+=k;const s=r,i=tt<<s-k-k,c=i*tt,f=(e-k)/c,o=(f-k)/tt,u=c-k,d=i,m=t.pow(n,f),v=t.pow(n,(f+k)/tt);let p=(N,g)=>{let C=m,_=t.pow(g,u),T=t.sqr(_);T=t.mul(T,g);let y=t.mul(N,T);y=t.pow(y,o),y=t.mul(y,_),_=t.mul(y,g),T=t.mul(y,N);let a=t.mul(T,_);y=t.pow(a,d);let w=t.eql(y,t.ONE);_=t.mul(T,v),y=t.mul(a,C),T=t.cmov(_,T,w),a=t.cmov(y,a,w);for(let b=s;b>k;b--){let x=b-tt;x=tt<<x-k;let O=t.pow(a,x);const U=t.eql(O,t.ONE);_=t.mul(T,C),C=t.mul(C,C),O=t.mul(a,C),T=t.cmov(_,T,U),a=t.cmov(O,a,U)}return{isValid:w,value:T}};if(t.ORDER%Gt===mt){const N=(t.ORDER-mt)/Gt,g=t.sqrt(t.neg(n));p=(C,_)=>{let T=t.sqr(_);const y=t.mul(C,_);T=t.mul(T,y);let a=t.pow(T,N);a=t.mul(a,y);const w=t.mul(a,g),b=t.mul(t.sqr(a),_),x=t.eql(b,C);let O=t.cmov(w,a,x);return{isValid:x,value:O}}}return p}function on(t,n){if(xe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=rn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,c,f,o,u,d,m;s=t.sqr(r),s=t.mul(s,n.Z),i=t.sqr(s),i=t.add(i,s),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),o=t.mul(u,n.A),i=t.add(i,o),i=t.mul(i,c),u=t.mul(u,f),o=t.mul(u,n.B),i=t.add(i,o),d=t.mul(s,c);const{isValid:v,value:p}=e(i,u);m=t.mul(s,r),m=t.mul(m,p),d=t.cmov(d,c,v),m=t.cmov(m,p,v);const N=t.isOdd(r)===t.isOdd(m);m=t.cmov(t.neg(m),m,N);const g=Ut(t,[f],!0)[0];return d=t.mul(d,g),{x:d,y:m}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function sn(t){return{hash:t,hmac:(n,...e)=>Ce(t,n,ke(...e)),randomBytes:he}}function cn(t,n){const e=r=>nn({...t,...sn(r)});return{...e(n),create:e}}const fn=$;function et(t,n){if(pt(t),pt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function an(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function pt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function un(t,n,e,r){nt(t),nt(n),pt(e),n.length>255&&(n=r(D(Jt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:i}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=D(n,et(n.length,1)),o=et(0,i),u=et(e,2),d=new Array(c),m=r(D(o,t,u,et(0,1),f));d[0]=r(D(m,et(1,1),f));for(let p=1;p<=c;p++){const N=[an(m,d[p-1]),et(p+1,1),f];d[p]=r(D(...N))}return D(...d).slice(0,e)}function ln(t,n,e,r,s){if(nt(t),nt(n),pt(e),n.length>255){const i=Math.ceil(2*r/8);n=s.create({dkLen:i}).update(Jt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(et(e,2)).update(n).update(et(n.length,1)).digest()}function ue(t,n,e){St(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:i,hash:c,expand:f,DST:o}=e;nt(t),pt(n);const u=typeof o=="string"?Jt(o):o,d=r.toString(2).length,m=Math.ceil((d+s)/8),v=n*i*m;let p;if(f==="xmd")p=un(t,u,v,c);else if(f==="xof")p=ln(t,u,v,s,c);else if(f==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');const N=new Array(n);for(let g=0;g<n;g++){const C=new Array(i);for(let _=0;_<i;_++){const T=m*(_+g*i),y=p.subarray(T,T+m);C[_]=L(fn(y),r)}N[g]=C}return N}function dn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[i,c,f,o]=e.map(m=>m.reduce((v,p)=>t.add(t.mul(v,r),p))),[u,d]=Ut(t,[c,o],!0);return r=t.mul(i,u),s=t.mul(s,t.mul(f,d)),{x:r,y:s}}}function hn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(i){return t.fromAffine(n(i))}function s(i){const c=i.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(i,c){const f=ue(i,2,{...e,DST:e.DST,...c}),o=r(f[0]),u=r(f[1]);return s(o.add(u))},encodeToCurve(i,c){const f=ue(i,1,{...e,DST:e.encodeDST,...c});return s(r(f[0]))},mapToCurve(i){if(!Array.isArray(i))throw new Error("expected array of bigints");for(const c of i)if(typeof c!="bigint")throw new Error("expected array of bigints");return s(r(i))}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const At=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),It=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),te=BigInt(0),vt=BigInt(1),Nt=BigInt(2),le=(t,n)=>(t+n/Nt)/n;function Ie(t){const n=At,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),u=t*t*t%n,d=u*u*t%n,m=j(d,e,n)*d%n,v=j(m,e,n)*d%n,p=j(v,Nt,n)*u%n,N=j(p,s,n)*p%n,g=j(N,i,n)*N%n,C=j(g,f,n)*g%n,_=j(C,o,n)*C%n,T=j(_,f,n)*g%n,y=j(T,e,n)*d%n,a=j(y,c,n)*N%n,w=j(a,r,n)*u%n,b=j(w,Nt,n);if(!rt.eql(rt.sqr(b),t))throw new Error("Cannot find square root");return b}const rt=Ft(At,void 0,void 0,{sqrt:Ie}),Zt=cn({a:te,b:BigInt(7),Fp:rt,n:It,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=It,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-vt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=le(i*t,n),o=le(-r*t,n);let u=L(t-f*e-o*s,n),d=L(-f*r-o*i,n);const m=u>c,v=d>c;if(m&&(u=n-u),v&&(d=n-d),u>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:m,k1:u,k2neg:v,k2:d}}}},Ot),de={};function Rt(t,...n){let e=de[t];if(e===void 0){const r=Ot(Uint8Array.from(t,s=>s.charCodeAt(0)));e=D(r,r),de[t]=e}return Ot(D(e,...n))}const ee=t=>t.toRawBytes(!0).slice(1),$t=t=>ft(t,32),Kt=t=>L(t,At),xt=t=>L(t,It),ne=(()=>Zt.ProjectivePoint)(),wn=(t,n,e)=>ne.BASE.multiplyAndAddUnsafe(t,n,e);function Xt(t){let n=Zt.utils.normPrivateKeyToScalar(t),e=ne.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:xt(-n),bytes:ee(e)}}function Ne(t){ct("x",t,vt,At);const n=Kt(t*t),e=Kt(n*t+BigInt(7));let r=Ie(e);r%Nt!==te&&(r=Kt(-r));const s=new ne(t,r,vt);return s.assertValidity(),s}const dt=$;function Re(...t){return xt(dt(Rt("BIP0340/challenge",...t)))}function gn(t){return Xt(t).bytes}function mn(t,n,e=he(32)){const r=V("message",t),{bytes:s,scalar:i}=Xt(n),c=V("auxRand",e,32),f=$t(i^dt(Rt("BIP0340/aux",c))),o=Rt("BIP0340/nonce",f,s,r),u=xt(dt(o));if(u===te)throw new Error("sign failed: k is zero");const{bytes:d,scalar:m}=Xt(u),v=Re(d,s,r),p=new Uint8Array(64);if(p.set(d,0),p.set($t(xt(m+v*i)),32),!Te(p,r,s))throw new Error("sign: Invalid signature produced");return p}function Te(t,n,e){const r=V("signature",t,64),s=V("message",n),i=V("publicKey",e,32);try{const c=Ne(dt(i)),f=dt(r.subarray(0,32));if(!Et(f,vt,At))return!1;const o=dt(r.subarray(32,64));if(!Et(o,vt,It))return!1;const u=Re($t(f),ee(c),s),d=wn(c,o,xt(-u));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const pn=(()=>({getPublicKey:gn,sign:mn,verify:Te,utils:{randomPrivateKey:Zt.utils.randomPrivateKey,lift_x:Ne,pointToBytes:ee,numberToBytesBE:ft,bytesToNumberBE:$,taggedHash:Rt,mod:L}}))(),yn=(()=>dn(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),bn=(()=>on(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}))(),Ue=(()=>hn(Zt.ProjectivePoint,t=>{const{x:n,y:e}=bn(rt.create(t[0]));return yn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:Ot}))(),vn=(()=>Ue.hashToCurve)(),xn=(()=>Ue.encodeToCurve)();export{xn as encodeToCurve,vn as hashToCurve,pn as schnorr,Zt as secp256k1,Ue as secp256k1_hasher};
